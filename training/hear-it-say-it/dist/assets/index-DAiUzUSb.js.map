{"version":3,"file":"index-DAiUzUSb.js","sources":["../../src/core/weighted-average.ts","../../src/data/character-sets.ts","../../src/state/store.ts","../../src/data/morse-codes.ts","../../src/components/progress-chart.ts","../../src/state/persistence.ts","../../src/core/morse-audio.ts","../../src/core/speech-recognition.ts","../../src/components/voice-calibration.ts","../../src/components/settings-panel.ts","../../src/components/mic-test.ts","../../src/data/word-lists.ts","../../src/core/word-selector.ts","../../src/components/mode-selector.ts","../../src/core/adaptive-selector.ts","../../src/core/callsign-generator.ts","../../src/core/callsign-validator.ts","../../src/services/practice-session.ts","../../src/services/permission-check.ts","../../src/main.ts"],"sourcesContent":["// Weighted Moving Average calculation\n// Uses exponential smoothing to give more weight to recent results\n\nconst WMA_DECAY = 0.15; // Weight given to new observation (0.15 = 15%)\nconst DEFAULT_WMA = 5000; // Default response time for new characters (ms)\nconst MAX_PENALTY_TIME = 5000; // Maximum penalty time for incorrect answers (ms)\n\n/**\n * Calculate proportional penalty time based on current WMA\n * Wrong answers penalize at 2x current WMA, capped at MAX_PENALTY_TIME\n */\nexport function calculatePenaltyTime(currentWMA: number): number {\n  return Math.min(currentWMA * 2, MAX_PENALTY_TIME);\n}\n\n/**\n * Calculate new WMA given previous WMA and new response time\n * Uses exponential weighted moving average formula:\n * WMA_new = (1 - decay) * WMA_old + decay * new_value\n */\nexport function calculateWMA(\n  previousWMA: number,\n  responseTime: number,\n  isCorrect: boolean\n): number {\n  const effectiveTime = isCorrect ? responseTime : calculatePenaltyTime(previousWMA);\n  return (1 - WMA_DECAY) * previousWMA + WMA_DECAY * effectiveTime;\n}\n\n/**\n * Get default WMA for a new character\n */\nexport function getDefaultWMA(): number {\n  return DEFAULT_WMA;\n}\n\n/**\n * Get the penalty time for incorrect responses\n * @param currentWMA - The current WMA to calculate proportional penalty\n */\nexport function getPenaltyTime(currentWMA: number): number {\n  return calculatePenaltyTime(currentWMA);\n}\n\n/**\n * Determine the performance level based on WMA\n * - 'icr': Instant Character Recognition (< 600ms)\n * - 'cr': Character Recognition (< 2000ms)\n * - 'learning': Still learning (>= 2000ms)\n */\nexport function getPerformanceLevel(wma: number): 'icr' | 'cr' | 'learning' {\n  if (wma < 600) return 'icr';\n  if (wma < 2000) return 'cr';\n  return 'learning';\n}\n\n/**\n * Get threshold values for chart display\n */\nexport const THRESHOLDS = {\n  ICR: 600, // Instant Character Recognition\n  CR: 2000, // Character Recognition\n  MAX: 5000, // Maximum (default/penalty)\n};\n","// CWops curriculum character sets (Sessions 1-10)\n// Each session adds new characters progressively\n\nexport const CHARACTER_SETS: Record<string, string> = {\n  'Standard': 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,/?',\n  'Session 1': 'AENT',\n  'Session 2': 'IOS14',\n  'Session 3': 'DHLR25',\n  'Session 4': 'CU',\n  'Session 5': 'MW36?',\n  'Session 6': 'FY,',\n  'Session 7': 'GPQ79/',\n  'Session 8': 'BV=', // = is BT prosign\n  'Session 9': 'JK08+', // + is AR prosign\n  'Session 10': 'XZ.>', // > is SK prosign\n  'Special': 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,/?=+>!',\n  'Letters Only': 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n  'Numbers Only': '0123456789',\n};\n\n// Sessions in order for cumulative selection\nexport const SESSION_ORDER = [\n  'Session 1',\n  'Session 2',\n  'Session 3',\n  'Session 4',\n  'Session 5',\n  'Session 6',\n  'Session 7',\n  'Session 8',\n  'Session 9',\n  'Session 10',\n];\n\n// Get cumulative characters up to and including a session\nexport function getSessionCharacters(upToSession: number): string {\n  let chars = '';\n  for (let i = 0; i < upToSession && i < SESSION_ORDER.length; i++) {\n    chars += CHARACTER_SETS[SESSION_ORDER[i]];\n  }\n  return chars;\n}\n\n// Get active characters based on selected sets, includes, and excludes\nexport function getActiveCharacters(\n  selectedSets: string[],\n  included: string[],\n  excluded: string[]\n): string[] {\n  const charSet = new Set<string>();\n\n  // Add characters from selected sets\n  for (const setName of selectedSets) {\n    const chars = CHARACTER_SETS[setName];\n    if (chars) {\n      for (const char of chars) {\n        charSet.add(char);\n      }\n    }\n  }\n\n  // Add manually included characters\n  for (const char of included) {\n    charSet.add(char);\n  }\n\n  // Remove excluded characters\n  for (const char of excluded) {\n    charSet.delete(char);\n  }\n\n  return Array.from(charSet).sort();\n}\n\n// Default character set for new users\nexport const DEFAULT_CHARACTER_SET = {\n  selectedSets: ['Standard'],\n  included: [] as string[],\n  excluded: [] as string[],\n};\n","import type {\n  AppState,\n  Settings,\n  CharacterSetConfig,\n  HistoryState,\n  SessionState,\n  CharacterHistory,\n  CalibrationState,\n  VoiceCalibration,\n  WordHistoryState,\n  WordCharacterHistory,\n  CallsignHistoryState,\n  CallsignCharacterHistory,\n  WordModeSettings,\n  CallsignModeSettings,\n  PronunciationAliases,\n} from '../types';\nimport { getDefaultWMA } from '../core/weighted-average';\nimport { DEFAULT_CHARACTER_SET, getActiveCharacters } from '../data/character-sets';\n\n// Default settings\nconst DEFAULT_SETTINGS: Settings = {\n  characterSpeed: 25,\n  adaptiveGain: 50,\n  toneFrequency: 700,\n  volume: 0.5,\n  repeatUntilCorrect: false,\n  strictNatoMode: false, // Default: accept any word starting with the correct letter\n};\n\n// Default session state\nconst DEFAULT_SESSION: SessionState = {\n  isRunning: false,\n  currentChar: null,\n  charPlayedAt: 0,\n  sessionStartTime: 0,\n  totalCharsThisSession: 0,\n  lastBreakReminder: 0,\n};\n\n// Default calibration state\nconst DEFAULT_CALIBRATION: CalibrationState = {\n  isCalibrated: false,\n  calibratedAt: 0,\n  calibration: {},\n};\n\n// Default word mode settings\nconst DEFAULT_WORD_MODE_SETTINGS: WordModeSettings = {\n  practiceMode: 'character',\n  wordLength: 3,\n};\n\n// Default callsign mode settings\nconst DEFAULT_CALLSIGN_MODE_SETTINGS: CallsignModeSettings = {\n  enabledFormats: ['2x3'], // Default to most common format\n};\n\n// Event listener type\ntype Listener<T> = (value: T) => void;\n\n// Simple reactive store\nclass Store {\n  private state: AppState;\n  private listeners: Map<string, Set<Listener<unknown>>> = new Map();\n\n  constructor() {\n    this.state = this.loadFromStorage() || this.getDefaultState();\n  }\n\n  private getDefaultState(): AppState {\n    return {\n      settings: { ...DEFAULT_SETTINGS },\n      characterSet: { ...DEFAULT_CHARACTER_SET },\n      history: {},\n      wordHistory: {},\n      callsignHistory: {},\n      wordModeSettings: { ...DEFAULT_WORD_MODE_SETTINGS },\n      callsignModeSettings: { ...DEFAULT_CALLSIGN_MODE_SETTINGS },\n      session: { ...DEFAULT_SESSION },\n      voiceCalibration: { ...DEFAULT_CALIBRATION },\n      pronunciationAliases: {},\n      wordPronunciationAliases: {},\n    };\n  }\n\n  private loadFromStorage(): AppState | null {\n    try {\n      const stored = localStorage.getItem('morse-icr-state');\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        // Merge with defaults to handle missing properties\n        return {\n          settings: { ...DEFAULT_SETTINGS, ...parsed.settings },\n          characterSet: { ...DEFAULT_CHARACTER_SET, ...parsed.characterSet },\n          history: parsed.history || {},\n          wordHistory: parsed.wordHistory || {},\n          callsignHistory: parsed.callsignHistory || {},\n          wordModeSettings: { ...DEFAULT_WORD_MODE_SETTINGS, ...parsed.wordModeSettings },\n          callsignModeSettings: { ...DEFAULT_CALLSIGN_MODE_SETTINGS, ...parsed.callsignModeSettings },\n          session: { ...DEFAULT_SESSION }, // Don't restore session state\n          voiceCalibration: { ...DEFAULT_CALIBRATION, ...parsed.voiceCalibration },\n          pronunciationAliases: parsed.pronunciationAliases || {},\n          wordPronunciationAliases: parsed.wordPronunciationAliases || {},\n        };\n      }\n    } catch (e) {\n      console.error('Failed to load state from storage:', e);\n    }\n    return null;\n  }\n\n  private saveToStorage(): void {\n    try {\n      const toSave = {\n        settings: this.state.settings,\n        characterSet: this.state.characterSet,\n        history: this.state.history,\n        wordHistory: this.state.wordHistory,\n        callsignHistory: this.state.callsignHistory,\n        wordModeSettings: this.state.wordModeSettings,\n        callsignModeSettings: this.state.callsignModeSettings,\n        voiceCalibration: this.state.voiceCalibration,\n        pronunciationAliases: this.state.pronunciationAliases,\n        wordPronunciationAliases: this.state.wordPronunciationAliases,\n      };\n      localStorage.setItem('morse-icr-state', JSON.stringify(toSave));\n    } catch (e) {\n      console.error('Failed to save state to storage:', e);\n    }\n  }\n\n  private emit(key: string, value: unknown): void {\n    const keyListeners = this.listeners.get(key);\n    if (keyListeners) {\n      keyListeners.forEach((listener) => listener(value));\n    }\n\n    // Also emit to wildcard listeners\n    const wildcardListeners = this.listeners.get('*');\n    if (wildcardListeners) {\n      wildcardListeners.forEach((listener) => listener(this.state));\n    }\n  }\n\n  // Subscribe to state changes\n  subscribe<K extends keyof AppState>(\n    key: K,\n    listener: Listener<AppState[K]>\n  ): () => void {\n    if (!this.listeners.has(key)) {\n      this.listeners.set(key, new Set());\n    }\n    this.listeners.get(key)!.add(listener as Listener<unknown>);\n\n    // Return unsubscribe function\n    return () => {\n      this.listeners.get(key)?.delete(listener as Listener<unknown>);\n    };\n  }\n\n  // Get current state\n  getState(): AppState {\n    return this.state;\n  }\n\n  // Settings\n  getSettings(): Settings {\n    return this.state.settings;\n  }\n\n  updateSettings(updates: Partial<Settings>): void {\n    this.state.settings = { ...this.state.settings, ...updates };\n    this.saveToStorage();\n    this.emit('settings', this.state.settings);\n  }\n\n  // Character set\n  getCharacterSet(): CharacterSetConfig {\n    return this.state.characterSet;\n  }\n\n  getActiveCharacters(): string[] {\n    const { selectedSets, included, excluded } = this.state.characterSet;\n    return getActiveCharacters(selectedSets, included, excluded);\n  }\n\n  updateCharacterSet(updates: Partial<CharacterSetConfig>): void {\n    this.state.characterSet = { ...this.state.characterSet, ...updates };\n    this.saveToStorage();\n    this.emit('characterSet', this.state.characterSet);\n  }\n\n  // History\n  getHistory(): HistoryState {\n    return this.state.history;\n  }\n\n  getCharacterHistory(char: string): CharacterHistory {\n    return (\n      this.state.history[char] || {\n        wma: getDefaultWMA(),\n        mostRecent: getDefaultWMA(),\n        totalAttempts: 0,\n        correctAttempts: 0,\n        lastPracticed: 0,\n      }\n    );\n  }\n\n  updateCharacterHistory(char: string, updates: Partial<CharacterHistory>): void {\n    const current = this.getCharacterHistory(char);\n    this.state.history[char] = { ...current, ...updates };\n    this.saveToStorage();\n    this.emit('history', this.state.history);\n  }\n\n  setHistory(history: HistoryState): void {\n    this.state.history = history;\n    this.saveToStorage();\n    this.emit('history', this.state.history);\n  }\n\n  resetHistory(): void {\n    this.state.history = {};\n    this.saveToStorage();\n    this.emit('history', this.state.history);\n  }\n\n  // Revert a character attempt (undo the last history update)\n  revertCharacterAttempt(char: string, wasCorrect: boolean, previousWMA: number, previousMostRecent: number): void {\n    const history = this.getCharacterHistory(char);\n    if (history.totalAttempts <= 0) return;\n\n    this.state.history[char] = {\n      ...history,\n      wma: previousWMA,\n      mostRecent: previousMostRecent,\n      totalAttempts: history.totalAttempts - 1,\n      correctAttempts: history.correctAttempts - (wasCorrect ? 1 : 0),\n    };\n    this.saveToStorage();\n    this.emit('history', this.state.history);\n  }\n\n  // Word History (character progress via word practice)\n  getWordHistory(): WordHistoryState {\n    return this.state.wordHistory;\n  }\n\n  getWordCharacterHistory(char: string): WordCharacterHistory {\n    return (\n      this.state.wordHistory[char] || {\n        wma: getDefaultWMA(),\n        mostRecent: getDefaultWMA(),\n        totalAttempts: 0,\n        correctAttempts: 0,\n        lastPracticed: 0,\n      }\n    );\n  }\n\n  updateWordCharacterHistory(char: string, updates: Partial<WordCharacterHistory>): void {\n    const current = this.getWordCharacterHistory(char);\n    this.state.wordHistory[char] = { ...current, ...updates };\n    this.saveToStorage();\n    this.emit('wordHistory', this.state.wordHistory);\n  }\n\n  setWordHistory(history: WordHistoryState): void {\n    this.state.wordHistory = history;\n    this.saveToStorage();\n    this.emit('wordHistory', this.state.wordHistory);\n  }\n\n  resetWordHistory(): void {\n    this.state.wordHistory = {};\n    this.saveToStorage();\n    this.emit('wordHistory', this.state.wordHistory);\n  }\n\n  // Revert word character attempts (undo the last history update for each char in word)\n  revertWordCharacterAttempts(\n    chars: string[],\n    wasCorrect: boolean,\n    previousWMAs: Record<string, { wma: number; mostRecent: number }>\n  ): void {\n    for (const char of chars) {\n      const history = this.getWordCharacterHistory(char);\n      if (history.totalAttempts <= 0) continue;\n\n      const prev = previousWMAs[char];\n      if (!prev) continue;\n\n      this.state.wordHistory[char] = {\n        ...history,\n        wma: prev.wma,\n        mostRecent: prev.mostRecent,\n        totalAttempts: history.totalAttempts - 1,\n        correctAttempts: history.correctAttempts - (wasCorrect ? 1 : 0),\n      };\n    }\n    this.saveToStorage();\n    this.emit('wordHistory', this.state.wordHistory);\n  }\n\n  // Callsign History (character progress via callsign practice)\n  getCallsignHistory(): CallsignHistoryState {\n    return this.state.callsignHistory;\n  }\n\n  getCallsignCharacterHistory(char: string): CallsignCharacterHistory {\n    return (\n      this.state.callsignHistory[char] || {\n        wma: getDefaultWMA(),\n        mostRecent: getDefaultWMA(),\n        totalAttempts: 0,\n        correctAttempts: 0,\n        lastPracticed: 0,\n      }\n    );\n  }\n\n  updateCallsignCharacterHistory(char: string, updates: Partial<CallsignCharacterHistory>): void {\n    const current = this.getCallsignCharacterHistory(char);\n    this.state.callsignHistory[char] = { ...current, ...updates };\n    this.saveToStorage();\n    this.emit('callsignHistory', this.state.callsignHistory);\n  }\n\n  setCallsignHistory(history: CallsignHistoryState): void {\n    this.state.callsignHistory = history;\n    this.saveToStorage();\n    this.emit('callsignHistory', this.state.callsignHistory);\n  }\n\n  resetCallsignHistory(): void {\n    this.state.callsignHistory = {};\n    this.saveToStorage();\n    this.emit('callsignHistory', this.state.callsignHistory);\n  }\n\n  // Revert callsign character attempts (undo the last history update for each char in callsign)\n  revertCallsignCharacterAttempts(\n    chars: string[],\n    wasCorrect: boolean,\n    previousWMAs: Record<string, { wma: number; mostRecent: number }>\n  ): void {\n    for (const char of chars) {\n      const history = this.getCallsignCharacterHistory(char);\n      if (history.totalAttempts <= 0) continue;\n\n      const prev = previousWMAs[char];\n      if (!prev) continue;\n\n      this.state.callsignHistory[char] = {\n        ...history,\n        wma: prev.wma,\n        mostRecent: prev.mostRecent,\n        totalAttempts: history.totalAttempts - 1,\n        correctAttempts: history.correctAttempts - (wasCorrect ? 1 : 0),\n      };\n    }\n    this.saveToStorage();\n    this.emit('callsignHistory', this.state.callsignHistory);\n  }\n\n  // Word Mode Settings\n  getWordModeSettings(): WordModeSettings {\n    return this.state.wordModeSettings;\n  }\n\n  updateWordModeSettings(updates: Partial<WordModeSettings>): void {\n    this.state.wordModeSettings = { ...this.state.wordModeSettings, ...updates };\n    this.saveToStorage();\n    this.emit('wordModeSettings', this.state.wordModeSettings);\n  }\n\n  // Callsign Mode Settings\n  getCallsignModeSettings(): CallsignModeSettings {\n    return this.state.callsignModeSettings;\n  }\n\n  updateCallsignModeSettings(updates: Partial<CallsignModeSettings>): void {\n    this.state.callsignModeSettings = { ...this.state.callsignModeSettings, ...updates };\n    this.saveToStorage();\n    this.emit('callsignModeSettings', this.state.callsignModeSettings);\n  }\n\n  // Session\n  getSession(): SessionState {\n    return this.state.session;\n  }\n\n  updateSession(updates: Partial<SessionState>): void {\n    this.state.session = { ...this.state.session, ...updates };\n    this.emit('session', this.state.session);\n  }\n\n  startSession(): void {\n    this.updateSession({\n      isRunning: true,\n      sessionStartTime: Date.now(),\n      totalCharsThisSession: 0,\n      lastBreakReminder: Date.now(),\n    });\n  }\n\n  stopSession(): void {\n    this.updateSession({\n      isRunning: false,\n      currentChar: null,\n    });\n  }\n\n  // Voice calibration\n  getVoiceCalibration(): CalibrationState {\n    return this.state.voiceCalibration;\n  }\n\n  isVoiceCalibrated(): boolean {\n    return this.state.voiceCalibration.isCalibrated;\n  }\n\n  getCalibrationForChar(char: string): string[] {\n    return this.state.voiceCalibration.calibration[char] || [];\n  }\n\n  // Add a heard transcript for a character during calibration\n  addCalibrationEntry(char: string, heardTranscript: string): void {\n    const current = this.state.voiceCalibration.calibration[char] || [];\n    // Avoid duplicates\n    if (!current.includes(heardTranscript.toLowerCase())) {\n      this.state.voiceCalibration.calibration[char] = [...current, heardTranscript.toLowerCase()];\n      this.saveToStorage();\n      this.emit('voiceCalibration', this.state.voiceCalibration);\n    }\n  }\n\n  // Set full calibration for a character (replaces existing)\n  setCalibrationForChar(char: string, transcripts: string[]): void {\n    this.state.voiceCalibration.calibration[char] = transcripts.map(t => t.toLowerCase());\n    this.saveToStorage();\n    this.emit('voiceCalibration', this.state.voiceCalibration);\n  }\n\n  // Mark calibration as complete\n  completeCalibration(): void {\n    this.state.voiceCalibration.isCalibrated = true;\n    this.state.voiceCalibration.calibratedAt = Date.now();\n    this.saveToStorage();\n    this.emit('voiceCalibration', this.state.voiceCalibration);\n  }\n\n  // Clear all calibration data\n  clearCalibration(): void {\n    this.state.voiceCalibration = { ...DEFAULT_CALIBRATION };\n    this.saveToStorage();\n    this.emit('voiceCalibration', this.state.voiceCalibration);\n  }\n\n  // Get the full user calibration map (for use in speech recognition)\n  getUserSpeechMap(): VoiceCalibration {\n    return this.state.voiceCalibration.calibration;\n  }\n\n  // Pronunciation Aliases - user-confirmed mappings from misheard text to expected character/word\n\n  // Get all aliases for character mode\n  getPronunciationAliases(): PronunciationAliases {\n    return this.state.pronunciationAliases;\n  }\n\n  // Get all aliases for word mode\n  getWordPronunciationAliases(): PronunciationAliases {\n    return this.state.wordPronunciationAliases;\n  }\n\n  // Get aliases for a specific expected character/word\n  getAliasesFor(expected: string, isWordMode: boolean): string[] {\n    const aliases = isWordMode\n      ? this.state.wordPronunciationAliases\n      : this.state.pronunciationAliases;\n    return aliases[expected.toUpperCase()] || [];\n  }\n\n  // Add a pronunciation alias (user accepted a misheard response)\n  addPronunciationAlias(expected: string, heardText: string, isWordMode: boolean): void {\n    const key = expected.toUpperCase();\n    const normalizedHeard = heardText.toUpperCase().trim();\n\n    // Don't add empty or very long strings\n    if (!normalizedHeard || normalizedHeard.length > 50) return;\n\n    const aliases = isWordMode\n      ? this.state.wordPronunciationAliases\n      : this.state.pronunciationAliases;\n\n    const current = aliases[key] || [];\n\n    // Avoid duplicates\n    if (!current.includes(normalizedHeard)) {\n      if (isWordMode) {\n        this.state.wordPronunciationAliases[key] = [...current, normalizedHeard];\n        this.emit('wordPronunciationAliases', this.state.wordPronunciationAliases);\n      } else {\n        this.state.pronunciationAliases[key] = [...current, normalizedHeard];\n        this.emit('pronunciationAliases', this.state.pronunciationAliases);\n      }\n      this.saveToStorage();\n    }\n  }\n\n  // Check if a heard transcript matches an alias for the expected character/word\n  matchesAlias(expected: string, heardText: string, isWordMode: boolean): boolean {\n    const aliases = this.getAliasesFor(expected, isWordMode);\n    const normalizedHeard = heardText.toUpperCase().trim();\n    return aliases.includes(normalizedHeard);\n  }\n\n  // Remove a specific alias\n  removeAlias(expected: string, alias: string, isWordMode: boolean): void {\n    const key = expected.toUpperCase();\n    const normalizedAlias = alias.toUpperCase().trim();\n\n    const aliases = isWordMode\n      ? this.state.wordPronunciationAliases\n      : this.state.pronunciationAliases;\n\n    const current = aliases[key] || [];\n    const filtered = current.filter(a => a !== normalizedAlias);\n\n    if (isWordMode) {\n      this.state.wordPronunciationAliases[key] = filtered;\n      this.emit('wordPronunciationAliases', this.state.wordPronunciationAliases);\n    } else {\n      this.state.pronunciationAliases[key] = filtered;\n      this.emit('pronunciationAliases', this.state.pronunciationAliases);\n    }\n    this.saveToStorage();\n  }\n\n  // Clear all pronunciation aliases\n  clearAllAliases(isWordMode: boolean): void {\n    if (isWordMode) {\n      this.state.wordPronunciationAliases = {};\n      this.emit('wordPronunciationAliases', this.state.wordPronunciationAliases);\n    } else {\n      this.state.pronunciationAliases = {};\n      this.emit('pronunciationAliases', this.state.pronunciationAliases);\n    }\n    this.saveToStorage();\n  }\n\n  // Full state import (for restore from file)\n  importState(imported: Partial<AppState>): void {\n    if (imported.settings) {\n      this.state.settings = { ...DEFAULT_SETTINGS, ...imported.settings };\n    }\n    if (imported.characterSet) {\n      this.state.characterSet = { ...DEFAULT_CHARACTER_SET, ...imported.characterSet };\n    }\n    if (imported.history) {\n      this.state.history = imported.history;\n    }\n    if (imported.wordHistory) {\n      this.state.wordHistory = imported.wordHistory;\n    }\n    if (imported.callsignHistory) {\n      this.state.callsignHistory = imported.callsignHistory;\n    }\n    if (imported.wordModeSettings) {\n      this.state.wordModeSettings = { ...DEFAULT_WORD_MODE_SETTINGS, ...imported.wordModeSettings };\n    }\n    if (imported.callsignModeSettings) {\n      this.state.callsignModeSettings = { ...DEFAULT_CALLSIGN_MODE_SETTINGS, ...imported.callsignModeSettings };\n    }\n    if (imported.pronunciationAliases) {\n      this.state.pronunciationAliases = imported.pronunciationAliases;\n    }\n    if (imported.wordPronunciationAliases) {\n      this.state.wordPronunciationAliases = imported.wordPronunciationAliases;\n    }\n    this.saveToStorage();\n    this.emit('settings', this.state.settings);\n    this.emit('characterSet', this.state.characterSet);\n    this.emit('history', this.state.history);\n    this.emit('wordHistory', this.state.wordHistory);\n    this.emit('callsignHistory', this.state.callsignHistory);\n    this.emit('wordModeSettings', this.state.wordModeSettings);\n    this.emit('callsignModeSettings', this.state.callsignModeSettings);\n    this.emit('pronunciationAliases', this.state.pronunciationAliases);\n    this.emit('wordPronunciationAliases', this.state.wordPronunciationAliases);\n  }\n}\n\n// Export singleton instance\nexport const store = new Store();\n","// Morse code definitions: character -> dit/dah pattern\n// '.' = dit, '-' = dah\nexport const MORSE_CODES: Record<string, string> = {\n  // Letters\n  'A': '.-',\n  'B': '-...',\n  'C': '-.-.',\n  'D': '-..',\n  'E': '.',\n  'F': '..-.',\n  'G': '--.',\n  'H': '....',\n  'I': '..',\n  'J': '.---',\n  'K': '-.-',\n  'L': '.-..',\n  'M': '--',\n  'N': '-.',\n  'O': '---',\n  'P': '.--.',\n  'Q': '--.-',\n  'R': '.-.',\n  'S': '...',\n  'T': '-',\n  'U': '..-',\n  'V': '...-',\n  'W': '.--',\n  'X': '-..-',\n  'Y': '-.--',\n  'Z': '--..',\n\n  // Numbers\n  '0': '-----',\n  '1': '.----',\n  '2': '..---',\n  '3': '...--',\n  '4': '....-',\n  '5': '.....',\n  '6': '-....',\n  '7': '--...',\n  '8': '---..',\n  '9': '----.',\n\n  // Punctuation\n  '.': '.-.-.-',\n  ',': '--..--',\n  '?': '..--..',\n  '/': '-..-.',\n};\n\n// Reverse lookup: morse pattern -> character\nexport const MORSE_TO_CHAR: Record<string, string> = Object.fromEntries(\n  Object.entries(MORSE_CODES).map(([char, code]) => [code, char])\n);\n\n// All available characters\nexport const ALL_CHARACTERS = Object.keys(MORSE_CODES);\n\n// Character display names (for special characters if needed)\nexport const CHAR_DISPLAY_NAMES: Record<string, string> = {};\n\n// Get display name for a character\nexport function getCharDisplayName(char: string): string {\n  return CHAR_DISPLAY_NAMES[char] || char;\n}\n","import { store } from '../state/store';\nimport { THRESHOLDS, getPerformanceLevel } from '../core/weighted-average';\nimport { getCharDisplayName } from '../data/morse-codes';\nimport type { HistoryState, WordHistoryState, CallsignHistoryState } from '../types';\n\nexport type ChartDataSource = 'individual' | 'word' | 'callsign';\n\n// Chart colors matching CSS variables\nconst COLORS = {\n  background: '#12121a',\n  gridLine: 'rgba(255, 255, 255, 0.1)',\n  text: '#888',\n  green: '#00d26a',\n  yellow: '#ffc107',\n  red: '#ff4757',\n  dot: '#1a1a2e',\n  dotBorder: '#f0f0f0',\n};\n\n// Chart configuration\nconst CONFIG = {\n  paddingTop: 30,\n  paddingBottom: 30,\n  paddingLeft: 50,\n  paddingRight: 10,\n  minBarGap: 1,\n  maxBarGap: 4,\n  minBarWidth: 4,\n  maxBarWidth: 25,\n  minDotRadius: 2,\n  maxDotRadius: 4,\n  yAxisMin: 100,\n  yAxisMax: 5000,\n};\n\nexport class ProgressChart {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private tooltip: HTMLDivElement | null = null;\n  private dataSource: ChartDataSource = 'individual';\n\n  constructor(canvasId: string) {\n    this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;\n    this.ctx = this.canvas.getContext('2d')!;\n\n    this.setupCanvas();\n    this.setupEventListeners();\n    this.render();\n\n    // Subscribe to history changes\n    store.subscribe('history', () => {\n      if (this.dataSource === 'individual') this.render();\n    });\n    store.subscribe('wordHistory', () => {\n      if (this.dataSource === 'word') this.render();\n    });\n    store.subscribe('callsignHistory', () => {\n      if (this.dataSource === 'callsign') this.render();\n    });\n    store.subscribe('characterSet', () => this.render());\n\n    // Handle resize\n    window.addEventListener('resize', () => {\n      this.render();\n    });\n  }\n\n  setDataSource(source: ChartDataSource): void {\n    if (this.dataSource !== source) {\n      this.dataSource = source;\n      this.render();\n    }\n  }\n\n  getDataSource(): ChartDataSource {\n    return this.dataSource;\n  }\n\n  private getHistory(): HistoryState | WordHistoryState | CallsignHistoryState {\n    if (this.dataSource === 'individual') return store.getHistory();\n    if (this.dataSource === 'word') return store.getWordHistory();\n    return store.getCallsignHistory();\n  }\n\n  private setupCanvas(): void {\n    const container = this.canvas.parentElement;\n    if (!container) return;\n\n    const containerRect = container.getBoundingClientRect();\n    const dpr = window.devicePixelRatio || 1;\n\n    // Always fit to container width - bars will scale to fit\n    const canvasWidth = containerRect.width;\n    const canvasHeight = containerRect.height;\n\n    this.canvas.width = canvasWidth * dpr;\n    this.canvas.height = canvasHeight * dpr;\n    this.ctx.scale(dpr, dpr);\n\n    // Set canvas CSS size\n    this.canvas.style.width = `${canvasWidth}px`;\n    this.canvas.style.height = `${canvasHeight}px`;\n  }\n\n  private setupEventListeners(): void {\n    this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));\n    this.canvas.addEventListener('mouseleave', () => this.hideTooltip());\n    this.canvas.addEventListener('touchstart', (e) => this.handleTouch(e));\n  }\n\n  private handleMouseMove(e: MouseEvent): void {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    this.checkHover(x, y);\n  }\n\n  private handleTouch(e: TouchEvent): void {\n    e.preventDefault();\n    const rect = this.canvas.getBoundingClientRect();\n    const touch = e.touches[0];\n    const x = touch.clientX - rect.left;\n    const y = touch.clientY - rect.top;\n    this.checkHover(x, y);\n  }\n\n  // Calculate bar dimensions that fit all characters on screen\n  private getBarDimensions(chartWidth: number, numChars: number): { barWidth: number; barGap: number; startX: number; dotRadius: number } {\n    if (numChars === 0) {\n      return { barWidth: 0, barGap: 0, startX: CONFIG.paddingLeft, dotRadius: CONFIG.maxDotRadius };\n    }\n\n    // Calculate the bar width to fit all bars in available space\n    // Total space = numChars * barWidth + (numChars - 1) * barGap\n    // We want barGap to be proportional to barWidth\n    const gapRatio = 0.2; // gap is 20% of bar width\n    // chartWidth = numChars * barWidth + (numChars - 1) * barWidth * gapRatio\n    // chartWidth = barWidth * (numChars + (numChars - 1) * gapRatio)\n    const denominator = numChars + (numChars - 1) * gapRatio;\n    let barWidth = chartWidth / denominator;\n\n    // Clamp bar width\n    barWidth = Math.min(CONFIG.maxBarWidth, Math.max(CONFIG.minBarWidth, barWidth));\n\n    // Calculate gap based on bar width\n    let barGap = barWidth * gapRatio;\n    barGap = Math.min(CONFIG.maxBarGap, Math.max(CONFIG.minBarGap, barGap));\n\n    // Calculate starting X to center the bars\n    const totalBarsWidth = numChars * barWidth + (numChars - 1) * barGap;\n    const startX = CONFIG.paddingLeft + Math.max(0, (chartWidth - totalBarsWidth) / 2);\n\n    // Scale dot radius with bar width\n    const dotRadius = Math.min(CONFIG.maxDotRadius, Math.max(CONFIG.minDotRadius, barWidth / 4));\n\n    return { barWidth, barGap, startX, dotRadius };\n  }\n\n  private checkHover(mouseX: number, _mouseY: number): void {\n    const activeChars = store.getActiveCharacters();\n    const history = this.getHistory();\n\n    const canvasWidth = parseFloat(this.canvas.style.width) || this.canvas.getBoundingClientRect().width;\n    const chartWidth = canvasWidth - CONFIG.paddingLeft - CONFIG.paddingRight;\n    const { barWidth, barGap, startX } = this.getBarDimensions(chartWidth, activeChars.length);\n\n    for (let i = 0; i < activeChars.length; i++) {\n      const char = activeChars[i];\n      const x = startX + i * (barWidth + barGap);\n\n      if (mouseX >= x && mouseX <= x + barWidth) {\n        const charHistory = history[char];\n        const wma = charHistory?.wma ?? 5000;\n        const mostRecent = charHistory?.mostRecent ?? 5000;\n\n        this.showTooltip(\n          char,\n          wma,\n          mostRecent,\n          x + barWidth / 2,\n          CONFIG.paddingTop\n        );\n        return;\n      }\n    }\n\n    this.hideTooltip();\n  }\n\n  private showTooltip(char: string, wma: number, mostRecent: number, x: number, y: number): void {\n    if (!this.tooltip) {\n      this.tooltip = document.createElement('div');\n      this.tooltip.style.cssText = `\n        position: absolute;\n        background: rgba(18, 18, 26, 0.95);\n        border: 1px solid rgba(255, 255, 255, 0.1);\n        border-radius: 8px;\n        padding: 8px 12px;\n        font-size: 12px;\n        color: #f0f0f0;\n        pointer-events: none;\n        z-index: 100;\n        backdrop-filter: blur(10px);\n        white-space: nowrap;\n      `;\n      this.canvas.parentElement?.appendChild(this.tooltip);\n    }\n\n    const displayChar = getCharDisplayName(char);\n    this.tooltip.innerHTML = `\n      <strong>${displayChar}</strong><br>\n      WMA: ${Math.round(wma)}ms<br>\n      Recent: ${Math.round(mostRecent)}ms\n    `;\n\n    this.tooltip.style.left = `${x}px`;\n    this.tooltip.style.top = `${y - 70}px`;\n    this.tooltip.style.display = 'block';\n  }\n\n  private hideTooltip(): void {\n    if (this.tooltip) {\n      this.tooltip.style.display = 'none';\n    }\n  }\n\n  // Convert value to Y position (logarithmic scale)\n  private valueToY(value: number, chartHeight: number): number {\n    const logMin = Math.log10(CONFIG.yAxisMin);\n    const logMax = Math.log10(CONFIG.yAxisMax);\n    const logValue = Math.log10(Math.max(CONFIG.yAxisMin, Math.min(CONFIG.yAxisMax, value)));\n\n    const ratio = (logValue - logMin) / (logMax - logMin);\n    return CONFIG.paddingTop + chartHeight * (1 - ratio);\n  }\n\n  render(): void {\n    // Recalculate canvas size based on characters\n    this.setupCanvas();\n\n    const width = parseFloat(this.canvas.style.width);\n    const height = parseFloat(this.canvas.style.height);\n    const chartHeight = height - CONFIG.paddingTop - CONFIG.paddingBottom;\n    const chartWidth = width - CONFIG.paddingLeft - CONFIG.paddingRight;\n\n    // Clear canvas\n    this.ctx.fillStyle = COLORS.background;\n    this.ctx.fillRect(0, 0, width, height);\n\n    const activeChars = store.getActiveCharacters();\n    const history = this.getHistory();\n\n    if (activeChars.length === 0) {\n      this.ctx.fillStyle = COLORS.text;\n      this.ctx.font = '14px system-ui';\n      this.ctx.textAlign = 'center';\n      this.ctx.fillText('No characters selected', width / 2, height / 2);\n      return;\n    }\n\n    // Check if history is empty for non-individual modes\n    if (this.dataSource === 'word' && Object.keys(history).length === 0) {\n      this.ctx.fillStyle = COLORS.text;\n      this.ctx.font = '14px system-ui';\n      this.ctx.textAlign = 'center';\n      this.ctx.fillText('No word practice history yet', width / 2, height / 2);\n      return;\n    }\n    if (this.dataSource === 'callsign' && Object.keys(history).length === 0) {\n      this.ctx.fillStyle = COLORS.text;\n      this.ctx.font = '14px system-ui';\n      this.ctx.textAlign = 'center';\n      this.ctx.fillText('No callsign practice history yet', width / 2, height / 2);\n      return;\n    }\n\n    // Calculate bar dimensions - fit all bars in available space\n    const { barWidth, barGap, startX, dotRadius } = this.getBarDimensions(chartWidth, activeChars.length);\n\n    // Draw bars first (so other elements render on top)\n    for (let i = 0; i < activeChars.length; i++) {\n      const char = activeChars[i];\n      const x = startX + i * (barWidth + barGap);\n      const charHistory = history[char];\n      const wma = charHistory?.wma ?? 5000;\n      const mostRecent = charHistory?.mostRecent ?? 5000;\n\n      // Draw bar (WMA)\n      const barY = this.valueToY(wma, chartHeight);\n      const barHeight = height - CONFIG.paddingBottom - barY;\n\n      const level = getPerformanceLevel(wma);\n      this.ctx.fillStyle =\n        level === 'icr' ? COLORS.green : level === 'cr' ? COLORS.yellow : COLORS.red;\n\n      // Use smaller corner radius for thin bars\n      const cornerRadius = Math.min(3, barWidth / 3);\n      this.ctx.beginPath();\n      this.ctx.roundRect(x, barY, barWidth, barHeight, [cornerRadius, cornerRadius, 0, 0]);\n      this.ctx.fill();\n\n      // Draw dot (most recent) - scale with bar size\n      const dotY = this.valueToY(mostRecent, chartHeight);\n      this.ctx.beginPath();\n      this.ctx.arc(x + barWidth / 2, dotY, dotRadius, 0, Math.PI * 2);\n      this.ctx.fillStyle = COLORS.dot;\n      this.ctx.fill();\n      this.ctx.strokeStyle = COLORS.dotBorder;\n      this.ctx.lineWidth = Math.max(1, dotRadius / 2);\n      this.ctx.stroke();\n\n      // Draw character label (only if bars are wide enough)\n      if (barWidth >= 6) {\n        this.ctx.fillStyle = COLORS.text;\n        const fontSize = Math.max(6, Math.min(10, barWidth - 1));\n        this.ctx.font = `${fontSize}px monospace`;\n        this.ctx.textAlign = 'center';\n        const displayChar = getCharDisplayName(char);\n        // Show single char for narrow bars\n        const label = barWidth < 12 ? displayChar.charAt(0) : (displayChar.length > 3 ? displayChar.substring(0, 2) : displayChar);\n        this.ctx.fillText(label, x + barWidth / 2, height - CONFIG.paddingBottom + fontSize + 2);\n      }\n    }\n\n    // Draw Y-axis background to cover any overlapping bars\n    this.ctx.fillStyle = COLORS.background;\n    this.ctx.fillRect(0, 0, CONFIG.paddingLeft - 5, height);\n\n    // Draw threshold lines ON TOP of bars\n    this.drawThresholdLines(chartHeight, width);\n\n    // Draw Y-axis labels ON TOP of bars\n    this.drawYAxis(chartHeight);\n  }\n\n  private drawThresholdLines(chartHeight: number, width: number): void {\n    // ICR threshold (600ms) - green\n    const icrY = this.valueToY(THRESHOLDS.ICR, chartHeight);\n    this.ctx.strokeStyle = COLORS.green;\n    this.ctx.lineWidth = 1;\n    this.ctx.setLineDash([5, 5]);\n    this.ctx.beginPath();\n    this.ctx.moveTo(CONFIG.paddingLeft, icrY);\n    this.ctx.lineTo(width - CONFIG.paddingRight, icrY);\n    this.ctx.stroke();\n\n    // CR threshold (2000ms) - yellow\n    const crY = this.valueToY(THRESHOLDS.CR, chartHeight);\n    this.ctx.strokeStyle = COLORS.yellow;\n    this.ctx.beginPath();\n    this.ctx.moveTo(CONFIG.paddingLeft, crY);\n    this.ctx.lineTo(width - CONFIG.paddingRight, crY);\n    this.ctx.stroke();\n\n    this.ctx.setLineDash([]);\n  }\n\n  private drawYAxis(chartHeight: number): void {\n    const labels = [100, 300, 600, 1000, 2000, 5000];\n\n    this.ctx.fillStyle = COLORS.text;\n    this.ctx.font = '10px system-ui';\n    this.ctx.textAlign = 'right';\n\n    for (const value of labels) {\n      const y = this.valueToY(value, chartHeight);\n      this.ctx.fillText(`${value}`, CONFIG.paddingLeft - 8, y + 3);\n\n      // Grid line\n      this.ctx.strokeStyle = COLORS.gridLine;\n      this.ctx.lineWidth = 1;\n      this.ctx.beginPath();\n      this.ctx.moveTo(CONFIG.paddingLeft, y);\n      this.ctx.lineTo(CONFIG.paddingLeft + 5, y);\n      this.ctx.stroke();\n    }\n  }\n}\n","import type { HistoryFile } from '../types';\nimport { store } from './store';\n\nconst FILE_VERSION = '1.2'; // Bumped version for pronunciation aliases support\n\n// Export history to JSON file\nexport function exportHistory(): void {\n  const state = store.getState();\n\n  const exportData: HistoryFile = {\n    version: FILE_VERSION,\n    exportedAt: new Date().toISOString(),\n    settings: state.settings,\n    characterSet: state.characterSet,\n    characters: state.history,\n    wordCharacters: state.wordHistory,\n    wordModeSettings: state.wordModeSettings,\n    pronunciationAliases: state.pronunciationAliases,\n    wordPronunciationAliases: state.wordPronunciationAliases,\n  };\n\n  const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n    type: 'application/json',\n  });\n\n  const url = URL.createObjectURL(blob);\n  const link = document.createElement('a');\n  link.href = url;\n\n  // Generate filename with timestamp\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);\n  link.download = `morse-icr-history-${timestamp}.json`;\n\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n  URL.revokeObjectURL(url);\n}\n\n// Import history from JSON file\nexport async function importHistory(file: File): Promise<boolean> {\n  try {\n    const text = await file.text();\n    const data = JSON.parse(text) as HistoryFile;\n\n    // Validate file format\n    if (!data.version || !data.characters) {\n      throw new Error('Invalid history file format');\n    }\n\n    // Import the data (word history and aliases fields are optional for backwards compatibility)\n    store.importState({\n      settings: data.settings,\n      characterSet: data.characterSet,\n      history: data.characters,\n      wordHistory: data.wordCharacters || {},\n      wordModeSettings: data.wordModeSettings,\n      pronunciationAliases: data.pronunciationAliases || {},\n      wordPronunciationAliases: data.wordPronunciationAliases || {},\n    });\n\n    return true;\n  } catch (e) {\n    console.error('Failed to import history:', e);\n    return false;\n  }\n}\n\n// Reset all history (both character and word)\nexport function resetAllHistory(): void {\n  if (confirm('Are you sure you want to reset all practice history? This cannot be undone.')) {\n    store.resetHistory();\n    store.resetWordHistory();\n  }\n}\n","import { MORSE_CODES } from '../data/morse-codes';\n\n// Singleton AudioContext\nlet audioContext: AudioContext | null = null;\n\n// Track active oscillators so we can cancel them\nlet activeOscillators: OscillatorNode[] = [];\nlet playbackAborted = false;\n\nfunction getAudioContext(): AudioContext {\n  if (!audioContext) {\n    audioContext = new AudioContext();\n  }\n  return audioContext;\n}\n\n// Stop all currently playing audio\nexport function stopAllAudio(): void {\n  playbackAborted = true;\n  for (const osc of activeOscillators) {\n    try {\n      osc.stop();\n      osc.disconnect();\n    } catch {\n      // Already stopped\n    }\n  }\n  activeOscillators = [];\n}\n\n// Resume audio context (required after user gesture on mobile)\nexport async function resumeAudioContext(): Promise<void> {\n  const ctx = getAudioContext();\n  if (ctx.state === 'suspended') {\n    await ctx.resume();\n  }\n}\n\n// Calculate morse timing based on WPM\n// PARIS standard: \"PARIS \" = 50 units, at 1 WPM takes 1 minute\n// Therefore: 1 unit = 60000ms / (50 * WPM) = 1200 / WPM ms\nfunction getMorseTiming(wpm: number) {\n  const ditDuration = 1200 / wpm;\n  return {\n    dit: ditDuration,\n    dah: ditDuration * 3,\n    intraCharGap: ditDuration, // gap between elements within a character\n    interCharGap: ditDuration * 3, // gap between characters (not used for single char)\n  };\n}\n\n// Play a single tone\nfunction playTone(\n  ctx: AudioContext,\n  frequency: number,\n  duration: number,\n  startTime: number,\n  volume: number\n): OscillatorNode {\n  const oscillator = ctx.createOscillator();\n  const gainNode = ctx.createGain();\n\n  oscillator.type = 'sine';\n  oscillator.frequency.value = frequency;\n\n  // Envelope to avoid clicks\n  const attackTime = 0.005;\n  const releaseTime = 0.005;\n\n  gainNode.gain.setValueAtTime(0, startTime);\n  gainNode.gain.linearRampToValueAtTime(volume, startTime + attackTime);\n  gainNode.gain.setValueAtTime(volume, startTime + duration - releaseTime);\n  gainNode.gain.linearRampToValueAtTime(0, startTime + duration);\n\n  oscillator.connect(gainNode);\n  gainNode.connect(ctx.destination);\n\n  oscillator.start(startTime);\n  oscillator.stop(startTime + duration);\n\n  // Track for cleanup\n  activeOscillators.push(oscillator);\n  oscillator.onended = () => {\n    activeOscillators = activeOscillators.filter((o) => o !== oscillator);\n  };\n\n  return oscillator;\n}\n\n// Play morse code for a character\nexport async function playMorseCharacter(\n  char: string,\n  wpm: number = 25,\n  frequency: number = 700,\n  volume: number = 0.5\n): Promise<boolean> {\n  // Stop any currently playing audio first\n  stopAllAudio();\n  playbackAborted = false;\n\n  const code = MORSE_CODES[char.toUpperCase()];\n  if (!code) {\n    console.warn(`No morse code found for character: ${char}`);\n    return false;\n  }\n\n  const ctx = getAudioContext();\n  await resumeAudioContext();\n\n  const timing = getMorseTiming(wpm);\n  let currentTime = ctx.currentTime + 0.05; // Small delay to ensure scheduling works\n\n  // Calculate total duration for the promise\n  let totalDuration = 0;\n\n  for (let i = 0; i < code.length; i++) {\n    const element = code[i];\n    const elementDuration = element === '.' ? timing.dit : timing.dah;\n\n    playTone(ctx, frequency, elementDuration / 1000, currentTime, volume);\n\n    currentTime += elementDuration / 1000;\n    totalDuration += elementDuration;\n\n    // Add gap between elements (except after the last one)\n    if (i < code.length - 1) {\n      currentTime += timing.intraCharGap / 1000;\n      totalDuration += timing.intraCharGap;\n    }\n  }\n\n  // Return a promise that resolves when playback is complete\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      // Return true if completed, false if aborted\n      resolve(!playbackAborted);\n    }, totalDuration + 50);\n  });\n}\n\n// Play morse code for a complete word with proper inter-character gaps\nexport async function playMorseWord(\n  word: string,\n  wpm: number = 25,\n  frequency: number = 700,\n  volume: number = 0.5\n): Promise<boolean> {\n  // Stop any currently playing audio first\n  stopAllAudio();\n  playbackAborted = false;\n\n  const ctx = getAudioContext();\n  await resumeAudioContext();\n\n  const timing = getMorseTiming(wpm);\n  let currentTime = ctx.currentTime + 0.05; // Small delay to ensure scheduling works\n  let totalDuration = 0;\n\n  const chars = word.toUpperCase().split('');\n\n  for (let charIndex = 0; charIndex < chars.length; charIndex++) {\n    const char = chars[charIndex];\n    const code = MORSE_CODES[char];\n\n    if (!code) {\n      console.warn(`No morse code found for character: ${char}`);\n      continue;\n    }\n\n    // Play each element of the character\n    for (let i = 0; i < code.length; i++) {\n      const element = code[i];\n      const elementDuration = element === '.' ? timing.dit : timing.dah;\n\n      playTone(ctx, frequency, elementDuration / 1000, currentTime, volume);\n\n      currentTime += elementDuration / 1000;\n      totalDuration += elementDuration;\n\n      // Intra-character gap (between elements within a character)\n      if (i < code.length - 1) {\n        currentTime += timing.intraCharGap / 1000;\n        totalDuration += timing.intraCharGap;\n      }\n    }\n\n    // Inter-character gap (between characters in the word)\n    if (charIndex < chars.length - 1) {\n      currentTime += timing.interCharGap / 1000;\n      totalDuration += timing.interCharGap;\n    }\n  }\n\n  // Return a promise that resolves when playback is complete\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      // Return true if completed, false if aborted\n      resolve(!playbackAborted);\n    }, totalDuration + 50);\n  });\n}\n\n// Play a test tone (for audio calibration)\nexport async function playTestTone(\n  frequency: number = 700,\n  duration: number = 500,\n  volume: number = 0.5\n): Promise<void> {\n  const ctx = getAudioContext();\n  await resumeAudioContext();\n\n  playTone(ctx, frequency, duration / 1000, ctx.currentTime, volume);\n\n  return new Promise((resolve) => {\n    setTimeout(resolve, duration);\n  });\n}\n\n// Play ascending tone for correct response\nexport async function playCorrectTone(volume: number = 0.3): Promise<void> {\n  const ctx = getAudioContext();\n  await resumeAudioContext();\n\n  const duration = 0.1; // 100ms per note\n  const now = ctx.currentTime;\n\n  // Ascending: C5 (523Hz) → E5 (659Hz)\n  playTone(ctx, 523, duration, now, volume);\n  playTone(ctx, 659, duration, now + duration, volume);\n}\n\n// Play descending tone for incorrect response\nexport async function playIncorrectTone(volume: number = 0.3): Promise<void> {\n  const ctx = getAudioContext();\n  await resumeAudioContext();\n\n  const duration = 0.1; // 100ms per note\n  const now = ctx.currentTime;\n\n  // Descending: E5 (659Hz) → C5 (523Hz)\n  playTone(ctx, 659, duration, now, volume);\n  playTone(ctx, 523, duration, now + duration, volume);\n}\n\n// Get the morse code pattern for a character (for display)\nexport function getMorsePattern(char: string): string {\n  return MORSE_CODES[char.toUpperCase()] || '';\n}\n","import type { RecognitionResult, VoiceCalibration } from '../types';\nimport { store } from '../state/store';\n\n// NATO phonetic alphabet - used for strict mode validation\nexport const NATO_ALPHABET: Record<string, string> = {\n  'alpha': 'A', 'bravo': 'B', 'charlie': 'C', 'delta': 'D',\n  'echo': 'E', 'foxtrot': 'F', 'golf': 'G', 'hotel': 'H',\n  'india': 'I', 'juliet': 'J', 'kilo': 'K', 'lima': 'L',\n  'mike': 'M', 'november': 'N', 'oscar': 'O', 'papa': 'P',\n  'quebec': 'Q', 'romeo': 'R', 'sierra': 'S', 'tango': 'T',\n  'uniform': 'U', 'victor': 'V', 'whiskey': 'W', 'xray': 'X',\n  'x-ray': 'X', 'yankee': 'Y', 'zulu': 'Z',\n  // Common variations\n  'alfa': 'A', 'juliett': 'J',\n};\n\n// Speech-to-character mapping\n// Supports direct letters, NATO phonetic alphabet, numbers, and prosigns\n// Also includes common misrecognitions from Web Speech API\nconst SPEECH_MAP: Record<string, string> = {\n  // Direct letters (lowercase)\n  'a': 'A', 'b': 'B', 'c': 'C', 'd': 'D', 'e': 'E', 'f': 'F', 'g': 'G',\n  'h': 'H', 'i': 'I', 'j': 'J', 'k': 'K', 'l': 'L', 'm': 'M', 'n': 'N',\n  'o': 'O', 'p': 'P', 'q': 'Q', 'r': 'R', 's': 'S', 't': 'T', 'u': 'U',\n  'v': 'V', 'w': 'W', 'x': 'X', 'y': 'Y', 'z': 'Z',\n\n  // NATO phonetic alphabet\n  'alpha': 'A', 'bravo': 'B', 'charlie': 'C', 'delta': 'D',\n  'echo': 'E', 'foxtrot': 'F', 'golf': 'G', 'hotel': 'H',\n  'india': 'I', 'juliet': 'J', 'kilo': 'K', 'lima': 'L',\n  'mike': 'M', 'november': 'N', 'oscar': 'O', 'papa': 'P',\n  'quebec': 'Q', 'romeo': 'R', 'sierra': 'S', 'tango': 'T',\n  'uniform': 'U', 'victor': 'V', 'whiskey': 'W', 'xray': 'X',\n  'x-ray': 'X', 'yankee': 'Y', 'zulu': 'Z',\n\n  // Common variations and NATO misspellings\n  'alfa': 'A', 'juliett': 'J', 'ecco': 'E', 'eco': 'E',\n\n  // Common Web Speech API misrecognitions for single letters\n  // (Note: single letter keys like 'a', 'b' etc are already defined above in Direct letters)\n  // A\n  'hey': 'A', 'ay': 'A', 'eh': 'A', 'aye': 'A', 'a.': 'A', 'aa': 'A', 'ah': 'A', 'ae': 'A',\n  // B\n  'be': 'B', 'bee': 'B', 'b.': 'B', 'bea': 'B', 'beat': 'B', 'bees': 'B', 'beef': 'B',\n  // C\n  'see': 'C', 'sea': 'C', 'c.': 'C', 'si': 'C', 'she': 'C', 'seat': 'C', 'seed': 'C',\n  // D\n  'de': 'D', 'dee': 'D', 'd.': 'D', 'the': 'D', 'deal': 'D', 'deep': 'D', 'dean': 'D',\n  // E\n  'he': 'E', 'ee': 'E', 'e.': 'E', 'ye': 'E', 'me': 'E', 'ea': 'E', 'eee': 'E', 'heat': 'E', 'eat': 'E', 'even': 'E',\n  // F\n  'ef': 'F', 'eff': 'F', 'f.': 'F', 'if': 'F', 'have': 'F', 'half': 'F', 'jeff': 'F',\n  // G\n  'gee': 'G', 'ge': 'G', 'g.': 'G', 'ji': 'G', 'jee': 'G', 'geez': 'G', 'jeez': 'G', 'jesus': 'G',\n  // H\n  'age': 'H', 'ach': 'H', 'h.': 'H', 'aitch': 'H', 'each': 'H', 'ache': 'H', 'ages': 'H',\n  // I\n  'eye': 'I', 'i.': 'I', 'hi': 'I', 'high': 'I', 'eyes': 'I', 'ice': 'I',\n  // J\n  'jay': 'J', 'je': 'J', 'j.': 'J', 'jae': 'J', 'jade': 'J', 'jays': 'J', 'jane': 'J', 'james': 'J',\n  // K\n  'kay': 'K', 'ke': 'K', 'k.': 'K', 'okay': 'K', 'ok': 'K', 'cake': 'K', 'kate': 'K', 'cay': 'K', 'kaye': 'K',\n  // L\n  'el': 'L', 'ell': 'L', 'l.': 'L', 'elle': 'L', 'ale': 'L', 'hell': 'L', 'well': 'L', 'bell': 'L',\n  // M\n  'em': 'M', 'm.': 'M', 'am': 'M', 'um': 'M', 'him': 'M', 'them': 'M', 'mm': 'M',\n  // N\n  'en': 'N', 'n.': 'N', 'and': 'N', 'an': 'N', 'in': 'N', 'end': 'N', 'hen': 'N', 'then': 'N', 'when': 'N',\n  // O\n  'oh': 'O', 'owe': 'O', 'o.': 'O', 'eau': 'O', 'oo': 'O', 'ooh': 'O', 'go': 'O', 'no': 'O', 'so': 'O', 'yo': 'O',\n  // P\n  'pea': 'P', 'pe': 'P', 'p.': 'P', 'pee': 'P', 'peak': 'P', 'peas': 'P', 'pete': 'P', 'peace': 'P',\n  // Q\n  'cue': 'Q', 'queue': 'Q', 'q.': 'Q', 'que': 'Q', 'cu': 'Q', 'cute': 'Q',\n  // R\n  'are': 'R', 'ar': 'R', 'r.': 'R', 'our': 'R', 'or': 'R', 'err': 'R', 'her': 'R',\n  // S\n  'es': 'S', 'ass': 'S', 's.': 'S', 'yes': 'S', 'is': 'S', 'us': 'S', 'this': 'S', 'has': 'S', 'was': 'S',\n  // T\n  'tea': 'T', 'tee': 'T', 't.': 'T', 'te': 'T', 'ti': 'T', 'teeth': 'T', 'teas': 'T', 'teen': 'T',\n  // U\n  'you': 'U', 'ewe': 'U', 'u.': 'U', 'ew': 'U', 'yu': 'U', 'yew': 'U', 'use': 'U', 'used': 'U', 'who': 'U',\n  // V\n  'vee': 'V', 've': 'V', 'v.': 'V', 'vi': 'V', 'fee': 'V', 'wee': 'V', 'visa': 'V',\n  // W\n  'double you': 'W', 'double u': 'W', 'w.': 'W', 'dub': 'W', 'dubs': 'W',\n  // X\n  'ex': 'X', 'x.': 'X', 'eggs': 'X', 'axe': 'X', 'ax': 'X', 'next': 'X', 'text': 'X', 'hex': 'X',\n  // Y\n  'why': 'Y', 'y.': 'Y', 'wie': 'Y', 'wye': 'Y', 'wise': 'Y', 'white': 'Y',\n  // Z\n  'zee': 'Z', 'zed': 'Z', 'z.': 'Z', 'ze': 'Z', 'said': 'Z', 'seas': 'Z', 'easy': 'Z',\n\n  // Numbers - digits\n  '0': '0', '1': '1', '2': '2', '3': '3', '4': '4',\n  '5': '5', '6': '6', '7': '7', '8': '8', '9': '9',\n\n  // Numbers - words\n  'zero': '0', 'one': '1', 'two': '2', 'three': '3', 'four': '4',\n  'five': '5', 'six': '6', 'seven': '7', 'eight': '8', 'nine': '9',\n  'niner': '9', // Ham radio convention\n  // Number misrecognitions\n  'to': '2', 'too': '2', 'for': '4', 'ate': '8', 'won': '1',\n  'tree': '3', 'free': '3', 'fiver': '5', 'sex': '6', 'sicks': '6',\n\n  // Punctuation\n  'period': '.', 'dot': '.', 'stop': '.', 'full stop': '.', '.': '.',\n  'comma': ',', ',': ',',\n  'question': '?', 'query': '?', 'question mark': '?', '?': '?',\n  'slash': '/', 'stroke': '/', 'forward slash': '/', '/': '/',\n\n  // Prosigns\n  'break': '=', 'bt': '=', 'pause': '=', 'bee tee': '=', '=': '=', 'equals': '=', 'equal': '=',\n  'over': '+', 'a r': '+', '+': '+', 'plus': '+',\n  'clear': '>', 'sk': '>', 'out': '>', 'silent key': '>', 's k': '>', '>': '>',\n};\n\n// Type definitions for Web Speech API\ninterface SpeechRecognitionEvent {\n  resultIndex: number;\n  results: SpeechRecognitionResultList;\n}\n\ninterface SpeechRecognitionResultList {\n  length: number;\n  [index: number]: SpeechRecognitionResult;\n}\n\ninterface SpeechRecognitionResult {\n  isFinal: boolean;\n  length: number;\n  [index: number]: SpeechRecognitionAlternative;\n}\n\ninterface SpeechRecognitionAlternative {\n  transcript: string;\n  confidence: number;\n}\n\ninterface SpeechRecognitionErrorEvent {\n  error: string;\n}\n\ninterface SpeechRecognitionInstance {\n  continuous: boolean;\n  interimResults: boolean;\n  maxAlternatives: number;\n  lang: string;\n  onresult: ((event: SpeechRecognitionEvent) => void) | null;\n  onerror: ((event: SpeechRecognitionErrorEvent) => void) | null;\n  onend: (() => void) | null;\n  start(): void;\n  stop(): void;\n}\n\n// Check if Web Speech API is supported\nexport function isSpeechRecognitionSupported(): boolean {\n  return 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;\n}\n\n// Detect if we're on iOS\nexport function isIOS(): boolean {\n  return /iPad|iPhone|iPod/.test(navigator.userAgent) ||\n    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);\n}\n\n// Detect if we're on Android\nexport function isAndroid(): boolean {\n  return /Android/i.test(navigator.userAgent);\n}\n\n// Detect if we're on any mobile device (iOS or Android)\nexport function isMobile(): boolean {\n  return isIOS() || isAndroid();\n}\n\n// Detect if we're using Chrome (not Edge which also has Chrome in UA)\nexport function isChrome(): boolean {\n  return /Chrome/i.test(navigator.userAgent) && !/Edg/i.test(navigator.userAgent);\n}\n\n// Build a reverse lookup from user calibration (heard transcript -> character)\nfunction buildUserSpeechMap(calibration: VoiceCalibration): Record<string, string> {\n  const userMap: Record<string, string> = {};\n  for (const [char, transcripts] of Object.entries(calibration)) {\n    for (const transcript of transcripts) {\n      userMap[transcript.toLowerCase()] = char;\n    }\n  }\n  return userMap;\n}\n\n// Normalize recognized text to a character\n// When expectedChar is provided and strictNatoMode is OFF, accepts any word starting with the expected letter\nexport function normalizeRecognizedText(text: string, expectedChar?: string): string | null {\n  const normalized = text.toLowerCase().trim();\n  const settings = store.getSettings();\n\n  // First, check user's personal calibration data (highest priority)\n  const userCalibration = store.getUserSpeechMap();\n  if (Object.keys(userCalibration).length > 0) {\n    const userMap = buildUserSpeechMap(userCalibration);\n\n    // Try exact match in user's calibration\n    if (userMap[normalized]) {\n      return userMap[normalized];\n    }\n\n    // Try first word only in user's calibration\n    const firstWord = normalized.split(' ')[0];\n    if (userMap[firstWord]) {\n      return userMap[firstWord];\n    }\n  }\n\n  // In strict NATO mode, only accept NATO phonetic words, single letters, and numbers/punctuation\n  if (settings.strictNatoMode) {\n    // Check NATO alphabet\n    if (NATO_ALPHABET[normalized]) {\n      return NATO_ALPHABET[normalized];\n    }\n\n    // Try first word for NATO\n    const firstWord = normalized.split(' ')[0];\n    if (NATO_ALPHABET[firstWord]) {\n      return NATO_ALPHABET[firstWord];\n    }\n\n    // Check single letters (a-z)\n    if (normalized.length === 1 && /^[a-z]$/.test(normalized)) {\n      return normalized.toUpperCase();\n    }\n\n    // Check numbers and punctuation from SPEECH_MAP\n    // (numbers, number words, punctuation, prosigns)\n    const nonLetterEntries = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n      'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'niner',\n      'to', 'too', 'for', 'ate', 'won', 'tree', 'free', 'fiver', 'sex', 'sicks',\n      'period', 'dot', 'stop', 'full stop', '.', 'comma', ',',\n      'question', 'query', 'question mark', '?', 'slash', 'stroke', 'forward slash', '/',\n      'break', 'bt', 'pause', 'bee tee', '=', 'equals', 'equal',\n      'over', 'a r', '+', 'plus', 'clear', 'sk', 'out', 'silent key', 's k', '>'];\n\n    if (nonLetterEntries.includes(normalized) && SPEECH_MAP[normalized]) {\n      return SPEECH_MAP[normalized];\n    }\n    if (nonLetterEntries.includes(firstWord) && SPEECH_MAP[firstWord]) {\n      return SPEECH_MAP[firstWord];\n    }\n\n    return null;\n  }\n\n  // Flexible mode (strictNatoMode is OFF)\n  // Fall back to default SPEECH_MAP\n  // Try exact match first\n  if (SPEECH_MAP[normalized]) {\n    return SPEECH_MAP[normalized];\n  }\n\n  // Try first word only (speech recognition often adds extra words)\n  const firstWord = normalized.split(' ')[0];\n  if (SPEECH_MAP[firstWord]) {\n    return SPEECH_MAP[firstWord];\n  }\n\n  // Try single letter if it's just one character\n  if (normalized.length === 1 && SPEECH_MAP[normalized]) {\n    return SPEECH_MAP[normalized];\n  }\n\n  // NEW: Flexible mode - accept any word starting with the expected letter (A-Z only)\n  if (expectedChar && /^[A-Z]$/.test(expectedChar.toUpperCase())) {\n    // Get the first letter of the spoken word\n    const spokenFirstLetter = firstWord.charAt(0).toUpperCase();\n    if (spokenFirstLetter === expectedChar.toUpperCase()) {\n      return expectedChar.toUpperCase();\n    }\n  }\n\n  return null;\n}\n\n// SpeechRecognition wrapper class\nexport class SpeechRecognizer {\n  private recognition: SpeechRecognitionInstance | null = null;\n  private isListening = false;\n  private onResultCallback: ((result: RecognitionResult) => void) | null = null;\n  private onErrorCallback: ((error: string) => void) | null = null;\n  private onRawCallback: ((rawTranscript: string, normalized: string | null) => void) | null = null;\n  private onEndCallback: (() => void) | null = null; // Called when recognition ends unexpectedly\n  private firstSpeechTime: number | null = null; // Track when user started speaking\n  private expectedChar: string | null = null; // Expected character for flexible mode validation\n\n  // Continuous mode: keep recognition running, only process results when accepting\n  private continuousMode = false;\n  private isAcceptingResults = false;\n  private lastIgnoredResultIndex = -1; // The resultIndex when we last called ignoreResults()\n  private callsignMode = false; // When true, wait for longer transcripts (multi-word callsigns)\n  private minWordCount = 1; // Minimum number of words before accepting (for callsign mode)\n\n  constructor() {\n    if (!isSpeechRecognitionSupported()) {\n      console.warn('Web Speech API not supported');\n      return;\n    }\n    // Don't create recognition instance here - create it fresh on each start()\n  }\n\n  private createRecognitionInstance(): void {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const SpeechRecognitionClass = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;\n    this.recognition = new SpeechRecognitionClass() as SpeechRecognitionInstance;\n\n    // Configure - continuous mode keeps listening without stopping\n    this.recognition.continuous = this.continuousMode;\n    this.recognition.interimResults = true;\n    this.recognition.maxAlternatives = 3;\n    this.recognition.lang = 'en-US';\n\n    this.setupEventHandlers();\n  }\n\n  // Enable continuous mode - recognition stays active, use acceptResults/ignoreResults to control\n  setContinuousMode(enabled: boolean): void {\n    this.continuousMode = enabled;\n  }\n\n  private setupEventHandlers(): void {\n    if (!this.recognition) return;\n\n    // Debug: track all recognition lifecycle events\n    (this.recognition as any).onstart = () => {\n      console.log('SpeechRecognizer onstart - recognition service started');\n    };\n    (this.recognition as any).onaudiostart = () => {\n      console.log('SpeechRecognizer onaudiostart - audio capture started');\n    };\n    (this.recognition as any).onsoundstart = () => {\n      console.log('SpeechRecognizer onsoundstart - sound detected');\n    };\n    (this.recognition as any).onspeechstart = () => {\n      console.log('SpeechRecognizer onspeechstart - speech detected');\n    };\n    (this.recognition as any).onspeechend = () => {\n      console.log('SpeechRecognizer onspeechend - speech ended');\n    };\n    (this.recognition as any).onsoundend = () => {\n      console.log('SpeechRecognizer onsoundend - sound ended');\n    };\n    (this.recognition as any).onaudioend = () => {\n      console.log('SpeechRecognizer onaudioend - audio capture ended');\n    };\n\n    this.recognition.onresult = (event: SpeechRecognitionEvent) => {\n      // In continuous mode, ignore results when not accepting (e.g., during audio playback)\n      if (this.continuousMode && !this.isAcceptingResults) {\n        return;\n      }\n\n      // In continuous mode, only handle one result per round\n      if (this.continuousMode && this.resultAlreadyHandled) {\n        return;\n      }\n\n      // Track the highest result index we've seen (used by ignoreResults to set cutoff)\n      if (event.resultIndex > this.lastProcessedResultIndex) {\n        this.lastProcessedResultIndex = event.resultIndex;\n      }\n\n      // In continuous mode, reject results from before we started accepting\n      // This prevents stale buffered results from previous utterances from being processed\n      if (this.continuousMode && event.resultIndex <= this.lastIgnoredResultIndex) {\n        console.log('Rejecting stale result (index', event.resultIndex, '<= lastIgnored', this.lastIgnoredResultIndex, ')');\n        return;\n      }\n\n      // Record first speech time when we first detect any speech\n      const now = performance.now();\n      if (this.firstSpeechTime === null) {\n        this.firstSpeechTime = now;\n        console.log('First speech detected, resultIndex:', event.resultIndex);\n      }\n\n      // Get the most confident result\n      for (let i = event.resultIndex; i < event.results.length; i++) {\n        const result = event.results[i];\n        const isWordMode = this.expectedChar === null;\n\n        // In word mode, handle results differently\n        if (isWordMode) {\n          if (result.length > 0) {\n            const transcript = result[0].transcript.trim();\n            const confidence = result[0].confidence;\n\n            // Report raw transcript for debugging\n            if (this.onRawCallback) {\n              const status = result.isFinal ? '' : ' (listening...)';\n              this.onRawCallback(transcript, transcript + status);\n            }\n\n            // Count words in transcript\n            const wordCount = transcript.split(/\\s+/).filter(w => w.length > 0).length;\n\n            // Send the result if:\n            // 1. It's marked as final, OR\n            // 2. For regular word mode: short transcript (1-5 chars)\n            // 3. For callsign mode: wait for minimum word count before accepting interim results\n            const isShortWord = transcript.length > 0 && transcript.length <= 5;\n            const hasEnoughWords = wordCount >= this.minWordCount;\n            const shouldSend = result.isFinal || (isShortWord && !this.callsignMode) || (this.callsignMode && hasEnoughWords && !result.isFinal);\n\n            // In callsign mode with enough words but not final, wait a bit more for additional words\n            // Only send interim results if we've been speaking for a while (prevents cutting off early)\n            if (this.callsignMode && !result.isFinal && hasEnoughWords) {\n              // Don't send yet - let the speech API finalize to capture more words\n              continue;\n            }\n\n            if (shouldSend && transcript.length > 0 && this.onResultCallback) {\n              const responseTimestamp = this.firstSpeechTime;\n              this.resultAlreadyHandled = true;\n\n              this.onResultCallback({\n                transcript: transcript,\n                rawTranscript: transcript,\n                confidence,\n                timestamp: responseTimestamp,\n              });\n\n              if (this.continuousMode) {\n                this.isAcceptingResults = false;\n              } else {\n                this.stop();\n              }\n              return;\n            }\n          }\n          continue; // Skip character mode processing for word mode\n        }\n\n        // Character mode: try all alternatives looking for a recognized character\n        for (let j = 0; j < result.length; j++) {\n          const transcript = result[j].transcript;\n          const confidence = result[j].confidence;\n\n          const normalizedChar = normalizeRecognizedText(transcript, this.expectedChar || undefined);\n\n          // Always report raw transcript for debugging\n          if (this.onRawCallback) {\n            this.onRawCallback(transcript, normalizedChar);\n          }\n\n          if (normalizedChar && this.onResultCallback) {\n            // Use first speech time for accurate response measurement\n            const responseTimestamp = this.firstSpeechTime;\n\n            // Mark as handled to prevent duplicate results from same speech\n            this.resultAlreadyHandled = true;\n\n            this.onResultCallback({\n              transcript: normalizedChar,\n              rawTranscript: transcript,\n              confidence,\n              timestamp: responseTimestamp,\n            });\n\n            // In continuous mode, just stop accepting (don't stop recognition)\n            // In normal mode, stop listening after successful recognition\n            if (result.isFinal) {\n              if (this.continuousMode) {\n                this.isAcceptingResults = false;\n              } else {\n                this.stop();\n              }\n            }\n            return;\n          }\n        }\n\n        // If this is a final result and we didn't find a match in any alternative,\n        // report it as unrecognized so it counts as wrong (character mode only)\n        if (result.isFinal && result.length > 0 && this.onResultCallback && this.expectedChar !== null) {\n          const transcript = result[0].transcript.trim();\n          // Only report if there's actual speech content (not empty)\n          if (transcript.length > 0) {\n            const responseTimestamp = this.firstSpeechTime;\n\n            // Mark as handled\n            this.resultAlreadyHandled = true;\n\n            // Send the raw transcript as-is (will be compared and fail)\n            // Use a special marker to indicate unrecognized speech\n            this.onResultCallback({\n              transcript: `[unrecognized:${transcript}]`,\n              rawTranscript: transcript,\n              confidence: result[0].confidence,\n              timestamp: responseTimestamp,\n            });\n\n            if (this.continuousMode) {\n              this.isAcceptingResults = false;\n            } else {\n              this.stop();\n            }\n            return;\n          }\n        }\n      }\n    };\n\n    this.recognition.onerror = (event: SpeechRecognitionErrorEvent) => {\n      console.log('SpeechRecognizer onerror:', event.error);\n\n      // no-speech and aborted are normal in continuous mode - let onend handle restart\n      if (event.error === 'no-speech' || event.error === 'aborted') {\n        // In continuous mode, don't stop listening - let onend auto-restart\n        if (!this.continuousMode) {\n          this.isListening = false;\n        }\n        return;\n      }\n\n      // Log actual errors\n      console.error('Speech recognition error:', event.error);\n      this.isListening = false;\n      if (this.onErrorCallback) {\n        this.onErrorCallback(event.error);\n      }\n    };\n\n    this.recognition.onend = () => {\n      console.log('SpeechRecognizer onend, continuousMode:', this.continuousMode, 'isListening:', this.isListening);\n\n      // In continuous mode, auto-restart to keep listening\n      if (this.continuousMode && this.isListening) {\n        console.log('Continuous mode: auto-restarting recognition');\n        try {\n          // Create a fresh instance for Android compatibility\n          // Android Chrome doesn't handle restarting the same instance well\n          this.createRecognitionInstance();\n          // Reset result tracking since new instance starts with resultIndex 0\n          this.lastIgnoredResultIndex = -1;\n          this.lastProcessedResultIndex = -1;\n          this.recognition?.start();\n        } catch (err) {\n          console.error('Failed to restart recognition:', err);\n          this.isListening = false;\n        }\n        return;\n      }\n\n      // In non-continuous mode, if we were still supposed to be listening\n      // (recognition ended due to no-speech timeout), notify the caller\n      const wasListening = this.isListening;\n      this.isListening = false;\n\n      if (wasListening && this.onEndCallback) {\n        console.log('Recognition ended unexpectedly, notifying caller');\n        this.onEndCallback();\n      }\n    };\n  }\n\n  start(): void {\n    if (!isSpeechRecognitionSupported()) {\n      console.error('Speech recognition not available');\n      return;\n    }\n\n    // Create a fresh recognition instance each time\n    // iOS Safari requires this - reusing instances causes failures\n    this.createRecognitionInstance();\n\n    this.isListening = true;\n    this.firstSpeechTime = null; // Reset for new listening session\n\n    // Reset result tracking for fresh instance\n    // New WebKit instance starts resultIndex at 0, so we must reset these\n    // otherwise stale detection will reject all results\n    this.lastIgnoredResultIndex = -1;\n    this.lastProcessedResultIndex = -1;\n    this.resultAlreadyHandled = false;\n\n    try {\n      console.log('SpeechRecognizer starting...');\n      this.recognition!.start();\n      console.log('SpeechRecognizer started');\n    } catch (err) {\n      console.error('Failed to start speech recognition:', err);\n      this.isListening = false;\n    }\n  }\n\n  stop(): void {\n    console.log('SpeechRecognizer stop() called, recognition exists:', !!this.recognition, 'isListening:', this.isListening);\n    this.isListening = false;\n    this.isAcceptingResults = false;\n    if (this.recognition) {\n      console.log('SpeechRecognizer: calling recognition.stop() now');\n      try {\n        this.recognition.stop();\n        console.log('SpeechRecognizer: recognition.stop() succeeded');\n      } catch (err) {\n        console.log('SpeechRecognizer: recognition.stop() threw:', err);\n        // Already stopped, ignore\n      }\n      // Don't null the instance here - iOS needs it alive for the stop chime\n      // The instance will be replaced on next start() anyway\n    } else {\n      console.log('SpeechRecognizer: no recognition instance to stop!');\n    }\n  }\n\n  // Full reset - clears all state for a fresh start\n  reset(): void {\n    console.log('SpeechRecognizer reset() called');\n    this.stop();\n    // Clear the instance after stop\n    this.recognition = null;\n    this.lastIgnoredResultIndex = -1;\n    this.lastProcessedResultIndex = -1;\n    this.resultAlreadyHandled = false;\n    this.firstSpeechTime = null;\n  }\n\n  // Start accepting results (for continuous mode)\n  acceptResults(): void {\n    this.isAcceptingResults = true;\n    this.firstSpeechTime = null; // Reset for new listening window\n    this.resultAlreadyHandled = false; // Allow new result\n    console.log('Accepting results, will reject resultIndex <=', this.lastIgnoredResultIndex);\n  }\n\n  // Track if we already handled a result this round (prevent duplicates)\n  private resultAlreadyHandled = false;\n  // Track the last result index we processed (to reject stale results after)\n  private lastProcessedResultIndex = -1;\n\n  // Stop accepting results but keep recognition running (for continuous mode)\n  // Also records the last processed result index so we can reject stale buffered results\n  ignoreResults(): void {\n    this.isAcceptingResults = false;\n    // Mark the current result index as the cutoff - any results at or below this\n    // will be rejected when we start accepting again\n    this.lastIgnoredResultIndex = this.lastProcessedResultIndex;\n    console.log('Ignoring results, lastIgnoredResultIndex set to:', this.lastIgnoredResultIndex);\n  }\n\n  // Set the expected character for flexible mode validation\n  setExpectedChar(char: string | null): void {\n    this.expectedChar = char;\n  }\n\n  // Set callsign mode - waits for longer transcripts before finalizing\n  setCallsignMode(enabled: boolean, expectedLength: number = 3): void {\n    this.callsignMode = enabled;\n    // For callsigns, expect at least as many words as characters in the callsign\n    this.minWordCount = enabled ? expectedLength : 1;\n    console.log('Callsign mode:', enabled, 'minWordCount:', this.minWordCount);\n  }\n\n  onResult(callback: (result: RecognitionResult) => void): void {\n    this.onResultCallback = callback;\n  }\n\n  onError(callback: (error: string) => void): void {\n    this.onErrorCallback = callback;\n  }\n\n  // Callback for ALL raw transcripts (even unrecognized ones) - useful for debugging\n  onRaw(callback: (rawTranscript: string, normalized: string | null) => void): void {\n    this.onRawCallback = callback;\n  }\n\n  // Callback when recognition ends unexpectedly (e.g., no-speech timeout in non-continuous mode)\n  onEnd(callback: () => void): void {\n    this.onEndCallback = callback;\n  }\n\n  isSupported(): boolean {\n    return isSpeechRecognitionSupported();\n  }\n\n  isActive(): boolean {\n    return this.isListening;\n  }\n}\n","import { store } from '../state/store';\nimport { SpeechRecognizer } from '../core/speech-recognition';\nimport { CHARACTER_SETS } from '../data/character-sets';\n\n// All characters that can be calibrated\nconst ALL_CALIBRATION_CHARS = CHARACTER_SETS['Standard'].split('');\n\nexport class VoiceCalibration {\n  private modal!: HTMLElement;\n  private currentCharEl!: HTMLElement;\n  private heardListEl!: HTMLElement;\n  private progressEl!: HTMLElement;\n  private progressTextEl!: HTMLElement;\n  private statusEl!: HTMLElement;\n  private nextBtn!: HTMLElement;\n  private skipBtn!: HTMLElement;\n  private finishBtn!: HTMLElement;\n  private cancelBtn!: HTMLElement;\n\n  private recognizer: SpeechRecognizer;\n  private currentIndex = 0;\n  private chars: string[] = [];\n  private isListening = false;\n  private heardTranscripts: string[] = [];\n\n  constructor() {\n    this.createModal();\n    this.recognizer = new SpeechRecognizer();\n    this.setupRecognizer();\n  }\n\n  private createModal(): void {\n    // Create modal HTML\n    const modalHtml = `\n      <div id=\"calibration-modal\" class=\"modal hidden\">\n        <div class=\"modal-content glass-card calibration-modal\">\n          <h2>Voice Calibration</h2>\n          <p class=\"calibration-instructions\">\n            Say each character clearly. We'll record how your voice sounds for better recognition.\n            You can say the letter multiple ways (e.g., \"E\", \"Echo\", or however you naturally say it).\n          </p>\n\n          <div class=\"calibration-progress\">\n            <div class=\"progress-bar\">\n              <div id=\"calibration-progress-fill\" class=\"progress-fill\"></div>\n            </div>\n            <span id=\"calibration-progress-text\">0 / 0</span>\n          </div>\n\n          <div class=\"calibration-char-display\">\n            <span class=\"label\">Say this character:</span>\n            <span id=\"calibration-current-char\" class=\"big-char\">A</span>\n          </div>\n\n          <div id=\"calibration-status\" class=\"calibration-status\">\n            Press \"Start Recording\" to begin\n          </div>\n\n          <div class=\"calibration-heard\">\n            <span class=\"label\">Heard patterns:</span>\n            <div id=\"calibration-heard-list\" class=\"heard-list\"></div>\n          </div>\n\n          <div class=\"calibration-controls\">\n            <button id=\"calibration-record-btn\" class=\"primary-btn\">Start Recording</button>\n            <button id=\"calibration-next-btn\" class=\"secondary-btn\" disabled>Next Character</button>\n            <button id=\"calibration-skip-btn\" class=\"secondary-btn\">Skip</button>\n          </div>\n\n          <div class=\"calibration-actions\">\n            <button id=\"calibration-cancel-btn\" class=\"danger-btn\">Cancel</button>\n            <button id=\"calibration-finish-btn\" class=\"primary-btn\" disabled>Finish Calibration</button>\n          </div>\n        </div>\n      </div>\n    `;\n\n    // Append to body\n    document.body.insertAdjacentHTML('beforeend', modalHtml);\n\n    // Get references\n    this.modal = document.getElementById('calibration-modal')!;\n    this.currentCharEl = document.getElementById('calibration-current-char')!;\n    this.heardListEl = document.getElementById('calibration-heard-list')!;\n    this.progressEl = document.getElementById('calibration-progress-fill')!;\n    this.progressTextEl = document.getElementById('calibration-progress-text')!;\n    this.statusEl = document.getElementById('calibration-status')!;\n    this.nextBtn = document.getElementById('calibration-next-btn')!;\n    this.skipBtn = document.getElementById('calibration-skip-btn')!;\n    this.finishBtn = document.getElementById('calibration-finish-btn')!;\n    this.cancelBtn = document.getElementById('calibration-cancel-btn')!;\n\n    const recordBtn = document.getElementById('calibration-record-btn')!;\n\n    // Event listeners\n    recordBtn.addEventListener('click', () => this.toggleRecording(recordBtn));\n    this.nextBtn.addEventListener('click', () => this.nextCharacter());\n    this.skipBtn.addEventListener('click', () => this.skipCharacter());\n    this.finishBtn.addEventListener('click', () => this.finishCalibration());\n    this.cancelBtn.addEventListener('click', () => this.close());\n  }\n\n  private setupRecognizer(): void {\n    // Listen to ALL transcripts during calibration\n    this.recognizer.onRaw((rawTranscript, _normalized) => {\n      if (!this.isListening) return;\n\n      const transcript = rawTranscript.toLowerCase().trim();\n      if (transcript && !this.heardTranscripts.includes(transcript)) {\n        this.heardTranscripts.push(transcript);\n        this.updateHeardList();\n\n        // Save to store immediately\n        const currentChar = this.chars[this.currentIndex];\n        store.addCalibrationEntry(currentChar, transcript);\n\n        // Enable next button after at least one recording\n        this.nextBtn.removeAttribute('disabled');\n      }\n    });\n  }\n\n  private toggleRecording(btn: HTMLElement): void {\n    if (this.isListening) {\n      this.stopRecording(btn);\n    } else {\n      this.startRecording(btn);\n    }\n  }\n\n  private startRecording(btn: HTMLElement): void {\n    this.isListening = true;\n    this.recognizer.start();\n    btn.textContent = 'Stop Recording';\n    btn.classList.add('recording');\n    this.statusEl.textContent = 'Listening... Say the character!';\n    this.statusEl.classList.add('listening');\n  }\n\n  private stopRecording(btn: HTMLElement): void {\n    this.isListening = false;\n    this.recognizer.stop();\n    btn.textContent = 'Start Recording';\n    btn.classList.remove('recording');\n    this.statusEl.textContent = this.heardTranscripts.length > 0\n      ? `Recorded ${this.heardTranscripts.length} pattern(s). Click Next or record more.`\n      : 'No patterns recorded. Try again or skip.';\n    this.statusEl.classList.remove('listening');\n  }\n\n  private updateHeardList(): void {\n    this.heardListEl.innerHTML = this.heardTranscripts\n      .map(t => `<span class=\"heard-tag\">${t}</span>`)\n      .join('');\n  }\n\n  private nextCharacter(): void {\n    // Stop any active recording\n    const recordBtn = document.getElementById('calibration-record-btn')!;\n    if (this.isListening) {\n      this.stopRecording(recordBtn);\n    }\n\n    this.currentIndex++;\n    if (this.currentIndex >= this.chars.length) {\n      // All done\n      this.finishBtn.removeAttribute('disabled');\n      this.statusEl.textContent = 'All characters calibrated! Click Finish to save.';\n      return;\n    }\n\n    this.showCurrentChar();\n  }\n\n  private skipCharacter(): void {\n    // Stop any active recording\n    const recordBtn = document.getElementById('calibration-record-btn')!;\n    if (this.isListening) {\n      this.stopRecording(recordBtn);\n    }\n\n    this.currentIndex++;\n    if (this.currentIndex >= this.chars.length) {\n      this.finishBtn.removeAttribute('disabled');\n      this.statusEl.textContent = 'Calibration complete! Click Finish to save.';\n      return;\n    }\n\n    this.showCurrentChar();\n  }\n\n  private showCurrentChar(): void {\n    const char = this.chars[this.currentIndex];\n    this.currentCharEl.textContent = char;\n\n    // Reset heard list for this character\n    this.heardTranscripts = [...store.getCalibrationForChar(char)];\n    this.updateHeardList();\n\n    // Update progress\n    const progress = ((this.currentIndex) / this.chars.length) * 100;\n    this.progressEl.style.width = `${progress}%`;\n    this.progressTextEl.textContent = `${this.currentIndex} / ${this.chars.length}`;\n\n    // Reset buttons\n    this.nextBtn.setAttribute('disabled', 'true');\n    if (this.heardTranscripts.length > 0) {\n      this.nextBtn.removeAttribute('disabled');\n    }\n\n    this.statusEl.textContent = 'Press \"Start Recording\" to begin';\n    this.statusEl.classList.remove('listening');\n  }\n\n  private finishCalibration(): void {\n    store.completeCalibration();\n    this.close();\n  }\n\n  open(chars?: string[]): void {\n    // Use provided chars or default to all\n    this.chars = chars || [...ALL_CALIBRATION_CHARS];\n    this.currentIndex = 0;\n    this.heardTranscripts = [];\n\n    // Reset finish button\n    this.finishBtn.setAttribute('disabled', 'true');\n\n    // Show first character\n    this.showCurrentChar();\n\n    // Show modal\n    this.modal.classList.remove('hidden');\n  }\n\n  close(): void {\n    // Stop recording if active\n    const recordBtn = document.getElementById('calibration-record-btn')!;\n    if (this.isListening) {\n      this.stopRecording(recordBtn);\n    }\n\n    this.modal.classList.add('hidden');\n  }\n}\n","import { store } from '../state/store';\nimport { SESSION_ORDER } from '../data/character-sets';\nimport { ALL_CHARACTERS, getCharDisplayName } from '../data/morse-codes';\nimport { exportHistory, importHistory, resetAllHistory } from '../state/persistence';\nimport { playTestTone } from '../core/morse-audio';\nimport { VoiceCalibration } from './voice-calibration';\nimport { isMobile } from '../core/speech-recognition';\n\nexport class SettingsPanel {\n  private panel: HTMLElement;\n  private settingsToggle: HTMLButtonElement;\n  private closeBtn: HTMLButtonElement;\n\n  // Sliders\n  private speedSlider: HTMLInputElement;\n  private speedValue: HTMLElement;\n  private gainSlider: HTMLInputElement;\n  private gainValue: HTMLElement;\n  private repeatToggle: HTMLInputElement;\n  private strictNatoToggle: HTMLInputElement;\n  private freqSlider: HTMLInputElement;\n  private freqValue: HTMLElement;\n\n  // Character selection\n  private characterSetsEl: HTMLElement;\n  private customCharsEl: HTMLElement;\n\n  // History buttons\n  private saveBtn: HTMLButtonElement;\n  private loadBtn: HTMLButtonElement;\n  private fileInput: HTMLInputElement;\n  private resetBtn: HTMLButtonElement;\n\n  // Voice calibration\n  private voiceCalibration: VoiceCalibration;\n  private calibrateBtn: HTMLButtonElement | null = null;\n  private clearCalibrationBtn: HTMLButtonElement | null = null;\n  private calibrationStatusEl: HTMLElement | null = null;\n\n  constructor() {\n    this.panel = document.getElementById('settings-panel') as HTMLElement;\n    this.settingsToggle = document.getElementById('settings-toggle') as HTMLButtonElement;\n    this.closeBtn = document.getElementById('close-settings') as HTMLButtonElement;\n\n    this.speedSlider = document.getElementById('speed-slider') as HTMLInputElement;\n    this.speedValue = document.getElementById('speed-value') as HTMLElement;\n    this.gainSlider = document.getElementById('gain-slider') as HTMLInputElement;\n    this.gainValue = document.getElementById('gain-value') as HTMLElement;\n    this.repeatToggle = document.getElementById('repeat-toggle') as HTMLInputElement;\n    this.strictNatoToggle = document.getElementById('strict-nato-toggle') as HTMLInputElement;\n    this.freqSlider = document.getElementById('freq-slider') as HTMLInputElement;\n    this.freqValue = document.getElementById('freq-value') as HTMLElement;\n\n    this.characterSetsEl = document.getElementById('character-sets') as HTMLElement;\n    this.customCharsEl = document.getElementById('custom-chars') as HTMLElement;\n\n    this.saveBtn = document.getElementById('save-history') as HTMLButtonElement;\n    this.loadBtn = document.getElementById('load-history') as HTMLButtonElement;\n    this.fileInput = document.getElementById('history-file') as HTMLInputElement;\n    this.resetBtn = document.getElementById('reset-history') as HTMLButtonElement;\n\n    // Initialize voice calibration\n    this.voiceCalibration = new VoiceCalibration();\n    this.insertCalibrationSection();\n\n    this.setupEventListeners();\n    this.initializeValues();\n    this.renderCharacterSets();\n    this.renderCustomCharacters();\n    this.updateCalibrationStatus();\n  }\n\n  private insertCalibrationSection(): void {\n    // Skip calibration section on mobile (uses continuous recognition mode instead)\n    if (isMobile()) return;\n\n    // Find the actions section and insert calibration section before it\n    const actionsSection = this.panel.querySelector('.setting-group.actions');\n    if (!actionsSection) return;\n\n    const calibrationSection = document.createElement('div');\n    calibrationSection.className = 'setting-group';\n    calibrationSection.innerHTML = `\n      <h3>Voice Calibration</h3>\n      <p class=\"calibration-info\">Train the app to recognize your voice for better accuracy.</p>\n      <div id=\"calibration-status\" class=\"calibration-status-display\"></div>\n      <div class=\"calibration-buttons\">\n        <button id=\"calibrate-btn\" class=\"secondary-btn\">Calibrate Voice</button>\n        <button id=\"clear-calibration-btn\" class=\"secondary-btn\" style=\"display: none;\">Clear Calibration</button>\n      </div>\n    `;\n\n    actionsSection.parentNode?.insertBefore(calibrationSection, actionsSection);\n\n    // Get references\n    this.calibrateBtn = document.getElementById('calibrate-btn') as HTMLButtonElement;\n    this.clearCalibrationBtn = document.getElementById('clear-calibration-btn') as HTMLButtonElement;\n    this.calibrationStatusEl = document.getElementById('calibration-status') as HTMLElement;\n\n    // Event listeners\n    this.calibrateBtn.addEventListener('click', () => {\n      this.voiceCalibration.open();\n    });\n\n    this.clearCalibrationBtn.addEventListener('click', () => {\n      if (confirm('Clear all voice calibration data?')) {\n        store.clearCalibration();\n        this.updateCalibrationStatus();\n      }\n    });\n\n    // Subscribe to calibration changes\n    store.subscribe('voiceCalibration', () => this.updateCalibrationStatus());\n  }\n\n  private updateCalibrationStatus(): void {\n    if (!this.calibrationStatusEl || !this.clearCalibrationBtn) return;\n\n    const calibration = store.getVoiceCalibration();\n    const charCount = Object.keys(calibration.calibration).length;\n\n    if (calibration.isCalibrated) {\n      const date = new Date(calibration.calibratedAt).toLocaleDateString();\n      this.calibrationStatusEl.innerHTML = `\n        <span class=\"status-icon\">✓</span>\n        Calibrated on ${date} (${charCount} characters)\n      `;\n      this.calibrationStatusEl.className = 'calibration-status-display calibrated';\n      this.clearCalibrationBtn.style.display = 'inline-block';\n    } else if (charCount > 0) {\n      this.calibrationStatusEl.innerHTML = `\n        <span class=\"status-icon\">⋯</span>\n        Partial calibration (${charCount} characters)\n      `;\n      this.calibrationStatusEl.className = 'calibration-status-display partial';\n      this.clearCalibrationBtn.style.display = 'inline-block';\n    } else {\n      this.calibrationStatusEl.innerHTML = `\n        <span class=\"status-icon\">○</span>\n        Not calibrated\n      `;\n      this.calibrationStatusEl.className = 'calibration-status-display';\n      this.clearCalibrationBtn.style.display = 'none';\n    }\n  }\n\n  private setupEventListeners(): void {\n    // Panel toggle\n    this.settingsToggle.addEventListener('click', () => this.toggle());\n    this.closeBtn.addEventListener('click', () => this.close());\n\n    // Close on click outside (on overlay)\n    this.panel.addEventListener('click', (e) => {\n      if (e.target === this.panel) this.close();\n    });\n\n    // Sliders\n    this.speedSlider.addEventListener('input', () => {\n      const value = parseInt(this.speedSlider.value);\n      this.speedValue.textContent = value.toString();\n      store.updateSettings({ characterSpeed: value });\n    });\n\n    this.gainSlider.addEventListener('input', () => {\n      const value = parseInt(this.gainSlider.value);\n      this.gainValue.textContent = value.toString();\n      store.updateSettings({ adaptiveGain: value });\n    });\n\n    this.repeatToggle.addEventListener('change', () => {\n      store.updateSettings({ repeatUntilCorrect: this.repeatToggle.checked });\n    });\n\n    this.strictNatoToggle.addEventListener('change', () => {\n      store.updateSettings({ strictNatoMode: this.strictNatoToggle.checked });\n    });\n\n    this.freqSlider.addEventListener('input', () => {\n      const value = parseInt(this.freqSlider.value);\n      this.freqValue.textContent = value.toString();\n      store.updateSettings({ toneFrequency: value });\n    });\n\n    // Play test tone on frequency change end\n    this.freqSlider.addEventListener('change', () => {\n      const settings = store.getSettings();\n      playTestTone(settings.toneFrequency, 200, settings.volume);\n    });\n\n    // History buttons\n    this.saveBtn.addEventListener('click', () => exportHistory());\n\n    this.loadBtn.addEventListener('click', () => this.fileInput.click());\n\n    this.fileInput.addEventListener('change', async () => {\n      const file = this.fileInput.files?.[0];\n      if (file) {\n        const success = await importHistory(file);\n        if (success) {\n          this.initializeValues();\n          this.renderCharacterSets();\n          this.renderCustomCharacters();\n          alert('History loaded successfully!');\n        } else {\n          alert('Failed to load history file.');\n        }\n        this.fileInput.value = '';\n      }\n    });\n\n    this.resetBtn.addEventListener('click', () => resetAllHistory());\n\n    // Subscribe to state changes\n    store.subscribe('settings', () => this.initializeValues());\n    store.subscribe('characterSet', () => {\n      this.renderCharacterSets();\n      this.renderCustomCharacters();\n    });\n  }\n\n  private initializeValues(): void {\n    const settings = store.getSettings();\n\n    this.speedSlider.value = settings.characterSpeed.toString();\n    this.speedValue.textContent = settings.characterSpeed.toString();\n\n    this.gainSlider.value = settings.adaptiveGain.toString();\n    this.gainValue.textContent = settings.adaptiveGain.toString();\n\n    this.repeatToggle.checked = settings.repeatUntilCorrect;\n    this.strictNatoToggle.checked = settings.strictNatoMode;\n\n    this.freqSlider.value = settings.toneFrequency.toString();\n    this.freqValue.textContent = settings.toneFrequency.toString();\n  }\n\n  private renderCharacterSets(): void {\n    const config = store.getCharacterSet();\n    const setNames = ['Standard', 'Letters Only', 'Numbers Only', ...SESSION_ORDER];\n\n    this.characterSetsEl.innerHTML = '';\n\n    for (const name of setNames) {\n      const btn = document.createElement('button');\n      btn.textContent = name;\n      btn.className = config.selectedSets.includes(name) ? 'active' : '';\n\n      btn.addEventListener('click', () => {\n        const current = store.getCharacterSet();\n        let newSets: string[];\n\n        if (current.selectedSets.includes(name)) {\n          // Remove if already selected\n          newSets = current.selectedSets.filter((s) => s !== name);\n        } else {\n          // Add to selection\n          newSets = [...current.selectedSets, name];\n        }\n\n        // Ensure at least one set is selected\n        if (newSets.length === 0) {\n          newSets = ['Standard'];\n        }\n\n        store.updateCharacterSet({ selectedSets: newSets });\n      });\n\n      this.characterSetsEl.appendChild(btn);\n    }\n  }\n\n  private renderCustomCharacters(): void {\n    const config = store.getCharacterSet();\n    const activeChars = store.getActiveCharacters();\n\n    this.customCharsEl.innerHTML = '';\n\n    for (const char of ALL_CHARACTERS) {\n      const btn = document.createElement('button');\n      btn.textContent = getCharDisplayName(char);\n\n      const isActive = activeChars.includes(char);\n      const isExcluded = config.excluded.includes(char);\n\n      if (isExcluded) {\n        btn.className = 'excluded';\n        btn.title = 'Excluded (click to include)';\n      } else if (isActive) {\n        btn.className = 'active';\n        btn.title = 'Active (click to exclude)';\n      } else {\n        btn.title = 'Not in selected sets (click to include)';\n      }\n\n      btn.addEventListener('click', () => {\n        const current = store.getCharacterSet();\n        let newIncluded = [...current.included];\n        let newExcluded = [...current.excluded];\n\n        if (current.excluded.includes(char)) {\n          // Was excluded -> make active\n          newExcluded = newExcluded.filter((c) => c !== char);\n        } else if (activeChars.includes(char)) {\n          // Was active -> exclude\n          newExcluded.push(char);\n          newIncluded = newIncluded.filter((c) => c !== char);\n        } else {\n          // Was inactive -> include\n          newIncluded.push(char);\n        }\n\n        store.updateCharacterSet({\n          included: newIncluded,\n          excluded: newExcluded,\n        });\n      });\n\n      this.customCharsEl.appendChild(btn);\n    }\n  }\n\n  toggle(): void {\n    this.panel.classList.toggle('hidden');\n    this.panel.classList.toggle('visible');\n  }\n\n  open(): void {\n    this.panel.classList.remove('hidden');\n    this.panel.classList.add('visible');\n  }\n\n  close(): void {\n    this.panel.classList.add('hidden');\n    this.panel.classList.remove('visible');\n  }\n}\n","import { isSpeechRecognitionSupported, isIOS, normalizeRecognizedText } from '../core/speech-recognition';\n\n// Type definitions for Web Speech API\ninterface SpeechRecognitionEvent {\n  resultIndex: number;\n  results: SpeechRecognitionResultList;\n}\n\ninterface SpeechRecognitionResultList {\n  length: number;\n  [index: number]: SpeechRecognitionResult;\n}\n\ninterface SpeechRecognitionResult {\n  isFinal: boolean;\n  length: number;\n  [index: number]: SpeechRecognitionAlternative;\n}\n\ninterface SpeechRecognitionAlternative {\n  transcript: string;\n  confidence: number;\n}\n\ninterface SpeechRecognitionErrorEvent {\n  error: string;\n}\n\ninterface SpeechRecognitionInstance {\n  continuous: boolean;\n  interimResults: boolean;\n  maxAlternatives: number;\n  lang: string;\n  onresult: ((event: SpeechRecognitionEvent) => void) | null;\n  onerror: ((event: SpeechRecognitionErrorEvent) => void) | null;\n  onend: (() => void) | null;\n  onaudiostart: (() => void) | null;\n  onstart: (() => void) | null;\n  onspeechstart: (() => void) | null;\n  onspeechend: (() => void) | null;\n  start(): void;\n  stop(): void;\n}\n\nexport class MicTest {\n  private testBtn: HTMLButtonElement;\n  private levelContainer: HTMLElement;\n  private levelBar: HTMLElement;\n  private resultEl: HTMLElement;\n\n  private recognition: SpeechRecognitionInstance | null = null;\n  private audioContext: AudioContext | null = null;\n  private analyser: AnalyserNode | null = null;\n  private mediaStream: MediaStream | null = null;\n  private animationId: number | null = null;\n  private isTesting = false;\n\n  constructor() {\n    this.testBtn = document.getElementById('mic-test-btn') as HTMLButtonElement;\n    this.levelContainer = document.getElementById('mic-level-container') as HTMLElement;\n    this.levelBar = document.getElementById('mic-level') as HTMLElement;\n    this.resultEl = document.getElementById('mic-result') as HTMLElement;\n\n    this.setupEventListeners();\n    this.checkSupport();\n  }\n\n  private checkSupport(): void {\n    if (!isSpeechRecognitionSupported()) {\n      const iosMsg = isIOS()\n        ? 'Speech recognition requires Safari on iOS. Also ensure Siri is enabled in Settings.'\n        : 'Speech recognition not supported. Try Chrome, Edge, or Safari.';\n      this.resultEl.innerHTML = `<span class=\"error\">${iosMsg}</span>`;\n      this.testBtn.disabled = true;\n      return;\n    }\n\n    // Initialize speech recognition\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const SpeechRecognitionClass = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;\n    this.recognition = new SpeechRecognitionClass() as SpeechRecognitionInstance;\n    this.recognition.continuous = false;\n    this.recognition.interimResults = true;\n    this.recognition.maxAlternatives = 5;\n    this.recognition.lang = 'en-US';\n\n    this.setupRecognitionHandlers();\n  }\n\n  private setupEventListeners(): void {\n    this.testBtn.addEventListener('click', () => this.toggleTest());\n  }\n\n  private setupRecognitionHandlers(): void {\n    if (!this.recognition) return;\n\n    this.recognition.onaudiostart = () => {\n      console.log('onaudiostart fired');\n      this.resultEl.innerHTML = '<span class=\"listening\">🎤 Listening... Say any letter (like \"A\", \"B\", \"Alpha\", etc.)</span>';\n    };\n\n    this.recognition.onstart = () => {\n      console.log('onstart fired - recognition is active');\n    };\n\n    this.recognition.onspeechstart = () => {\n      console.log('onspeechstart fired - speech detected');\n    };\n\n    this.recognition.onspeechend = () => {\n      console.log('onspeechend fired - speech ended');\n    };\n\n    this.recognition.onresult = (event: SpeechRecognitionEvent) => {\n      let bestTranscript = '';\n      let bestNormalized: string | null = null;\n\n      // Check all results and alternatives\n      for (let i = event.resultIndex; i < event.results.length; i++) {\n        const result = event.results[i];\n        for (let j = 0; j < result.length; j++) {\n          const transcript = result[j].transcript;\n          const normalized = normalizeRecognizedText(transcript);\n\n          if (!bestTranscript) {\n            bestTranscript = transcript;\n          }\n          if (normalized && !bestNormalized) {\n            bestNormalized = normalized;\n          }\n        }\n\n        if (result.isFinal) {\n          this.stopTest();\n\n          if (bestNormalized) {\n            this.resultEl.innerHTML = `\n              <span class=\"success\">✓ Heard: \"${bestTranscript}\" → Recognized as: <strong>${bestNormalized}</strong></span>\n              <br><small style=\"color: var(--text-muted);\">Microphone is working! You can start practicing.</small>\n            `;\n          } else {\n            this.resultEl.innerHTML = `\n              <span class=\"error\">✗ Heard: \"${bestTranscript}\" - Not recognized as a valid character.</span>\n              <br><small style=\"color: var(--text-muted);\">Try saying a single letter like \"A\", \"B\", or use NATO phonetic like \"Alpha\", \"Bravo\".</small>\n            `;\n          }\n          return;\n        }\n      }\n\n      // Show interim results\n      if (bestTranscript) {\n        this.resultEl.innerHTML = `<span class=\"listening\">Hearing: \"${bestTranscript}\"...</span>`;\n      }\n    };\n\n    this.recognition.onerror = (event: SpeechRecognitionErrorEvent) => {\n      console.log('onerror fired:', event.error);\n\n      if (event.error === 'not-allowed') {\n        this.resultEl.innerHTML = `\n          <span class=\"error\">✗ Microphone access denied!</span>\n          <br><small style=\"color: var(--text-muted);\">Click the lock icon in your browser's address bar and allow microphone access, then refresh.</small>\n        `;\n        this.stopTest();\n      } else if (event.error === 'no-speech') {\n        this.resultEl.innerHTML = `\n          <span class=\"error\">✗ No speech detected.</span>\n          <br><small style=\"color: var(--text-muted);\">Make sure your microphone is working and speak clearly. Check your system audio settings.</small>\n        `;\n        this.stopTest();\n      } else if (event.error === 'audio-capture') {\n        this.resultEl.innerHTML = `\n          <span class=\"error\">✗ No microphone found!</span>\n          <br><small style=\"color: var(--text-muted);\">Please connect a microphone and refresh the page.</small>\n        `;\n        this.stopTest();\n      }\n    };\n\n    this.recognition.onend = () => {\n      console.log('onend fired - isTesting:', this.isTesting);\n      if (this.isTesting) {\n        // Timed out without result\n        this.resultEl.innerHTML = `\n          <span class=\"error\">✗ No speech detected in time.</span>\n          <br><small style=\"color: var(--text-muted);\">Try again - speak clearly and loudly.</small>\n        `;\n        this.stopTest();\n      }\n    };\n  }\n\n  private async toggleTest(): Promise<void> {\n    if (this.isTesting) {\n      this.stopTest();\n    } else {\n      await this.startTest();\n    }\n  }\n\n  private async startTest(): Promise<void> {\n    this.isTesting = true;\n    this.testBtn.textContent = 'Stop Test';\n    this.testBtn.classList.add('testing');\n    this.levelContainer.classList.remove('hidden');\n    this.resultEl.innerHTML = '<span class=\"listening\">Starting microphone...</span>';\n\n    // iOS Safari quirk: recreate SpeechRecognition instance on each test\n    // Some iOS versions require a fresh instance from a user gesture\n    if (isSpeechRecognitionSupported()) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const SpeechRecognitionClass = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;\n      this.recognition = new SpeechRecognitionClass() as SpeechRecognitionInstance;\n      this.recognition.continuous = false;\n      this.recognition.interimResults = true;\n      this.recognition.maxAlternatives = 5;\n      this.recognition.lang = 'en-US';\n      this.setupRecognitionHandlers();\n      console.log('Created fresh SpeechRecognition instance');\n    }\n\n    // Start audio level visualization\n    try {\n      this.mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      this.audioContext = new AudioContext();\n      this.analyser = this.audioContext.createAnalyser();\n      const source = this.audioContext.createMediaStreamSource(this.mediaStream);\n      source.connect(this.analyser);\n      this.analyser.fftSize = 256;\n      this.updateLevel();\n\n      // Log which device is being used\n      const tracks = this.mediaStream.getAudioTracks();\n      if (tracks.length > 0) {\n        console.log('Using microphone:', tracks[0].label);\n        this.resultEl.innerHTML = `<span class=\"listening\">Using: ${tracks[0].label || 'Default Microphone'}</span>`;\n      }\n    } catch (err) {\n      console.error('Failed to get audio stream:', err);\n      this.resultEl.innerHTML = `\n        <span class=\"error\">✗ Could not access microphone.</span>\n        <br><small style=\"color: var(--text-muted);\">Please allow microphone access when prompted.</small>\n      `;\n      this.stopTest();\n      return;\n    }\n\n    // Start Web Speech API recognition\n    if (this.recognition) {\n      try {\n        console.log('Calling recognition.start()...');\n        this.recognition.start();\n        console.log('recognition.start() called successfully');\n      } catch (err) {\n        console.error('Failed to start recognition:', err);\n        this.resultEl.innerHTML = `\n          <span class=\"error\">✗ Failed to start speech recognition</span>\n          <br><small style=\"color: var(--text-muted);\">Error: ${err}</small>\n        `;\n      }\n    }\n  }\n\n  private stopTest(): void {\n    this.isTesting = false;\n    this.testBtn.textContent = 'Test Microphone';\n    this.testBtn.classList.remove('testing');\n    this.levelContainer.classList.add('hidden');\n    this.levelBar.style.width = '0%';\n\n    if (this.recognition) {\n      try {\n        this.recognition.stop();\n      } catch {\n        // Ignore\n      }\n    }\n\n    if (this.animationId) {\n      cancelAnimationFrame(this.animationId);\n      this.animationId = null;\n    }\n\n    if (this.mediaStream) {\n      this.mediaStream.getTracks().forEach(track => track.stop());\n      this.mediaStream = null;\n    }\n\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n  }\n\n  private updateLevel(): void {\n    if (!this.analyser || !this.isTesting) return;\n\n    const dataArray = new Uint8Array(this.analyser.frequencyBinCount);\n    this.analyser.getByteFrequencyData(dataArray);\n\n    // Calculate average volume\n    const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;\n    const level = Math.min(100, (average / 128) * 100);\n\n    this.levelBar.style.width = `${level}%`;\n\n    this.animationId = requestAnimationFrame(() => this.updateLevel());\n  }\n}\n","// Word lists for word mode practice\n// Words are selected to be:\n// - Easy to pronounce clearly\n// - Phonetically distinct (not easily confused with other words)\n// - Common enough to be recognizable\n\nexport type WordLength = 3 | 4 | 5;\n\nexport interface WordLists {\n  3: string[];\n  4: string[];\n  5: string[];\n}\n\n// 3-letter words\n// Removed words that sound like letters: TEA, BEE, SEA, PEA, GEE, JAY, KAY, KEY, OWE, WHY, EYE, ARE, YOU, YEW, CUE, EWE\nconst THREE_LETTER_WORDS: string[] = [\n  'ACE', 'ACT', 'ADD', 'AGE', 'AID', 'AIM', 'AIR', 'ANT', 'APE', 'ARC',\n  'ARK', 'ARM', 'ART', 'ASH', 'AXE', 'BAD', 'BAG', 'BAT', 'BED', 'BIG',\n  'BIT', 'BOW', 'BOX', 'BOY', 'BUD', 'BUG', 'BUS', 'BUT', 'BUY', 'CAB',\n  'CAP', 'CAR', 'CAT', 'COB', 'COD', 'COG', 'COP', 'COT', 'COW', 'CRY',\n  'CUB', 'CUP', 'CUT', 'DAM', 'DAY', 'DEN', 'DEW', 'DIG', 'DIM', 'DOC',\n  'DOG', 'DOT', 'DRY', 'DUG', 'DYE', 'EAR', 'EAT', 'EGG', 'ELF', 'ELK',\n  'ELM', 'END', 'ERA', 'FAN', 'FAR', 'FAT', 'FAX', 'FED', 'FIG',\n  'FIN', 'FIT', 'FIX', 'FLY', 'FOB', 'FOG', 'FOR', 'FOX', 'FUN', 'FUR',\n  'GAP', 'GAS', 'GEL', 'GEM', 'GIG', 'GIN', 'GNU', 'GOB', 'GOD', 'GUM',\n  'GUN', 'GUT', 'GUY', 'GYM', 'HAM', 'HAT', 'HAY', 'HEN', 'HID', 'HIP',\n  'HIT', 'HOB', 'HOG', 'HOP', 'HOT', 'HUB', 'HUG', 'HUM', 'HUT', 'ICE',\n  'ICY', 'IMP', 'INK', 'INN', 'ION', 'IVY', 'JAB', 'JAM', 'JAR', 'JAW',\n  'JET', 'JIG', 'JOB', 'JOG', 'JOT', 'JOY', 'JUG', 'KID', 'KIN',\n  'KIT', 'LAB', 'LAD', 'LAP', 'LAW', 'LAY', 'LED', 'LEG', 'LET', 'LID',\n  'LIP', 'LIT', 'LOG', 'LOT', 'LOW', 'MAD', 'MAN', 'MAP', 'MAT', 'MAX',\n  'MEN', 'MET', 'MIX', 'MOB', 'MOM', 'MOP', 'MUD', 'MUG', 'NAP', 'NET',\n  'NEW', 'NIT', 'NOD', 'NOR', 'NOT', 'NOW', 'NUN', 'NUT', 'OAK', 'OAR',\n  'OAT', 'ODD', 'OIL', 'OLD', 'ONE', 'OPT', 'ORB', 'ORE', 'OUR', 'OUT',\n  'OWL', 'OWN', 'PAD', 'PAN', 'PAT', 'PAW', 'PAY', 'PEG',\n  'PEN', 'PET', 'PIE', 'PIG', 'PIN', 'PIT', 'PLY', 'POD', 'POP', 'POT',\n  'PRY', 'PUB', 'PUN', 'PUP', 'PUT', 'RAG', 'RAM', 'RAN', 'RAP', 'RAT',\n  'RAW', 'RAY', 'RED', 'REP', 'RIB', 'RID', 'RIG', 'RIM', 'RIP', 'ROB',\n  'ROD', 'ROT', 'ROW', 'RUB', 'RUG', 'RUN', 'RUT', 'RYE', 'SAD', 'SAP',\n  'SAT', 'SAW', 'SAY', 'SET', 'SEW', 'SHY', 'SIN', 'SIP', 'SIS',\n  'SIT', 'SIX', 'SKI', 'SKY', 'SLY', 'SOB', 'SOD', 'SON', 'SOP', 'SOT',\n  'SOW', 'SOY', 'SPA', 'SPY', 'STY', 'SUB', 'SUM', 'SUN', 'TAB', 'TAG',\n  'TAN', 'TAP', 'TAR', 'TAX', 'TEN', 'THE', 'TIE', 'TIN', 'TIP',\n  'TOE', 'TON', 'TOO', 'TOP', 'TOT', 'TOW', 'TOY', 'TUB', 'TUG', 'TWO',\n  'URN', 'USE', 'VAN', 'VAT', 'VET', 'VIA', 'VOW', 'WAD', 'WAR', 'WAS',\n  'WAX', 'WAY', 'WEB', 'WED', 'WET', 'WHO', 'WIG', 'WIN', 'WIT',\n  'WOK', 'WON', 'WOO', 'YAK', 'YAM', 'YAP', 'YAW', 'YEN', 'YES', 'YET',\n  'YIN', 'ZIP', 'ZIT', 'ZOO',\n];\n\n// 4-letter words (~150 words)\nconst FOUR_LETTER_WORDS: string[] = [\n  'ABLE', 'ACHE', 'ACID', 'AGED', 'AIDE', 'AIMS', 'ALSO', 'ARCH', 'AREA',\n  'ARMY', 'AUNT', 'AUTO', 'BABY', 'BACK', 'BAKE', 'BALL', 'BAND', 'BANK',\n  'BARN', 'BASE', 'BATH', 'BEAD', 'BEAM', 'BEAN', 'BEAR', 'BEAT', 'BEEF',\n  'BEER', 'BELL', 'BELT', 'BEND', 'BENT', 'BEST', 'BIKE', 'BIRD', 'BITE',\n  'BLOW', 'BLUE', 'BOAT', 'BODY', 'BOIL', 'BOLD', 'BOLT', 'BOMB', 'BOND',\n  'BONE', 'BOOK', 'BOOM', 'BOOT', 'BORN', 'BOSS', 'BOTH', 'BOWL', 'BROW',\n  'BULB', 'BULK', 'BULL', 'BUMP', 'BURN', 'BUSH', 'BUSY', 'CAFE', 'CAGE',\n  'CAKE', 'CALF', 'CALL', 'CALM', 'CAME', 'CAMP', 'CANE', 'CAPE', 'CARD',\n  'CARE', 'CART', 'CASE', 'CASH', 'CAST', 'CAVE', 'CELL', 'CHEF', 'CHIN',\n  'CHIP', 'CHOP', 'CITY', 'CLAM', 'CLAP', 'CLAY', 'CLIP', 'CLUB', 'CLUE',\n  'COAL', 'COAT', 'CODE', 'COIL', 'COIN', 'COLD', 'COLT', 'COMB', 'COME',\n  'CONE', 'COOK', 'COOL', 'COPE', 'COPY', 'CORD', 'CORE', 'CORK', 'CORN',\n  'COST', 'COZY', 'CRAB', 'CREW', 'CROP', 'CROW', 'CUBE', 'CULT', 'CUPS',\n  'CURB', 'CURE', 'CURL', 'CUTE', 'DAMP', 'DARE', 'DARK', 'DASH', 'DATA',\n  'DATE', 'DAWN', 'DAYS', 'DEAD', 'DEAF', 'DEAL', 'DEAN', 'DEAR', 'DEBT',\n  'DECK', 'DEED', 'DEEP', 'DEER', 'DEMO', 'DENY', 'DESK', 'DIAL', 'DICE',\n  'DIET', 'DIME', 'DINE', 'DIRT', 'DISC', 'DISH', 'DISK', 'DIVE', 'DOCK',\n  'DOES', 'DOLL', 'DOME', 'DONE', 'DOOR', 'DOSE', 'DOWN', 'DRAW', 'DREW',\n  'DRIP', 'DROP', 'DRUM', 'DUAL', 'DUCK', 'DUDE', 'DUEL', 'DUKE', 'DULL',\n  'DUMP', 'DUNE', 'DUNK', 'DUSK', 'DUST', 'DUTY', 'EACH', 'EARL', 'EARN',\n  'EASE', 'EAST', 'EASY', 'ECHO', 'EDGE', 'EDIT', 'ELSE', 'EPIC', 'EURO',\n  'EVEN', 'EVIL', 'EXAM', 'EXIT', 'EXPO', 'FACE', 'FACT', 'FADE', 'FAIL',\n  'FAIR', 'FAKE', 'FALL', 'FAME', 'FARM', 'FAST', 'FATE', 'FAWN', 'FEAR',\n  'FEAT', 'FEED', 'FEEL', 'FEET', 'FELL', 'FELT', 'FERN', 'FEST', 'FEUD',\n  'FILE', 'FILL', 'FILM', 'FIND', 'FINE', 'FIRE', 'FIRM', 'FISH', 'FIST',\n  'FLAG', 'FLAP', 'FLAT', 'FLAW', 'FLEA', 'FLED', 'FLEW', 'FLIP', 'FLOW',\n  'FOAM', 'FOIL', 'FOLD', 'FOLK', 'FOND', 'FONT', 'FOOD', 'FOOL', 'FOOT',\n  'FORD', 'FORK', 'FORM', 'FORT', 'FOUL', 'FOUR', 'FOWL', 'FREE', 'FROM',\n  'FROG', 'FUEL', 'FULL', 'FUME', 'FUND', 'FUNK', 'FUSE', 'FUSS', 'GAIN',\n  'GALE', 'GAME', 'GANG', 'GASP', 'GATE', 'GAVE', 'GAZE', 'GEAR', 'GENE',\n  'GIFT', 'GIRL', 'GIVE', 'GLAD', 'GLOW', 'GLUE', 'GOAL', 'GOAT', 'GOES',\n  'GOLD', 'GOLF', 'GONE', 'GOOD', 'GOWN', 'GRAB', 'GRAM', 'GRAY', 'GREW',\n  'GRID', 'GRIM', 'GRIN', 'GRIP', 'GRIT', 'GROW', 'GULF', 'GURU', 'GUST',\n  'HACK', 'HAIL', 'HAIR', 'HALF', 'HALL', 'HALT', 'HAND', 'HANG', 'HARD',\n  'HARM', 'HARP', 'HATE', 'HAUL', 'HAVE', 'HAWK', 'HEAD', 'HEAL', 'HEAP',\n  'HEAR', 'HEAT', 'HEEL', 'HELD', 'HELP', 'HEMP', 'HERB', 'HERD', 'HERE',\n  'HERO', 'HIGH', 'HIKE', 'HILL', 'HINT', 'HIRE', 'HOLD', 'HOLE', 'HOME',\n  'HOOD', 'HOOK', 'HOPE', 'HORN', 'HOST', 'HOUR', 'HUGE', 'HULL', 'HUNG',\n  'HUNT', 'HURT', 'HUSK', 'ICON', 'IDEA', 'IDLE', 'INCH', 'INTO', 'IRON',\n  'ITEM', 'JACK', 'JADE', 'JAIL', 'JAZZ', 'JEAN', 'JEEP', 'JEST', 'JOBS',\n  'JOIN', 'JOKE', 'JOLT', 'JUMP', 'JUNE', 'JUNK', 'JURY', 'JUST', 'KEEN',\n  'KEEP', 'KELP', 'KEPT', 'KICK', 'KIDS', 'KILL', 'KIND', 'KING', 'KISS',\n  'KITE', 'KNEE', 'KNEW', 'KNIT', 'KNOB', 'KNOT', 'KNOW', 'LACE', 'LACK',\n  'LAKE', 'LAMB', 'LAMP', 'LAND', 'LANE', 'LARD', 'LAST', 'LATE', 'LAWN',\n  'LEAD', 'LEAF', 'LEAK', 'LEAN', 'LEAP', 'LEFT', 'LEND', 'LENS', 'LESS',\n  'LIDS', 'LIFE', 'LIFT', 'LIKE', 'LIMB', 'LIME', 'LIMP', 'LINE', 'LINK',\n  'LION', 'LIPS', 'LIST', 'LIVE', 'LOAD', 'LOAF', 'LOAN', 'LOBE', 'LOCK',\n  'LOFT', 'LOGO', 'LONG', 'LOOK', 'LOOP', 'LORD', 'LOSE', 'LOSS', 'LOST',\n  'LOTS', 'LOUD', 'LOVE', 'LUCK', 'LUMP', 'LUNG', 'LURE', 'MADE', 'MAID',\n  'MAIL', 'MAIN', 'MAKE', 'MALE', 'MALL', 'MALT', 'MANY', 'MAPS', 'MARE',\n  'MARK', 'MARS', 'MASH', 'MASK', 'MASS', 'MAST', 'MATE', 'MATH', 'MEAL',\n  'MEAN', 'MEAT', 'MEEK', 'MEET', 'MELT', 'MEMO', 'MENU', 'MESH', 'MESS',\n  'MILD', 'MILE', 'MILK', 'MILL', 'MIND', 'MINE', 'MINT', 'MISS', 'MIST',\n  'MODE', 'MOLD', 'MONK', 'MOOD', 'MOON', 'MOOR', 'MORE', 'MOSS', 'MOST',\n  'MOTH', 'MOVE', 'MUCH', 'MULE', 'MUST', 'MYTH', 'NAIL', 'NAME', 'NAVY',\n  'NEAR', 'NEAT', 'NECK', 'NEED', 'NEST', 'NEWS', 'NEXT', 'NICE', 'NINE',\n  'NODE', 'NONE', 'NOON', 'NORM', 'NOSE', 'NOTE', 'NOUN', 'NUDE', 'NUTS',\n  'OATH', 'ODDS', 'OILS', 'OKAY', 'ONCE', 'ONLY', 'ONTO', 'OPEN', 'ORAL',\n  'OVEN', 'OVER', 'PACE', 'PACK', 'PAGE', 'PAID', 'PAIL', 'PAIN', 'PAIR',\n  'PALE', 'PALM', 'PANE', 'PARK', 'PART', 'PASS', 'PAST', 'PATH', 'PEAK',\n  'PEAR', 'PEAS', 'PEAT', 'PECK', 'PEEK', 'PEEL', 'PEER', 'PELT', 'PENS',\n  'PERK', 'PEST', 'PICK', 'PIER', 'PIKE', 'PILE', 'PILL', 'PINE', 'PINK',\n  'PINT', 'PIPE', 'PITS', 'PLAN', 'PLAY', 'PLEA', 'PLOD', 'PLOT', 'PLOW',\n  'PLUG', 'PLUM', 'PLUS', 'POCK', 'PODS', 'POEM', 'POET', 'POLE', 'POLL',\n  'POLO', 'POND', 'PONY', 'POOL', 'POOR', 'POPE', 'PORK', 'PORT', 'POSE',\n  'POST', 'POUR', 'PRAY', 'PREY', 'PROP', 'PULL', 'PULP', 'PUMP', 'PUNK',\n  'PURE', 'PUSH', 'QUIT', 'QUIZ', 'RACE', 'RACK', 'RAFT', 'RAGE', 'RAID',\n  'RAIL', 'RAIN', 'RAKE', 'RAMP', 'RANG', 'RANK', 'RARE', 'RASH', 'RATE',\n  'RAVE', 'READ', 'REAL', 'REAP', 'REAR', 'REED', 'REEF', 'REEL', 'RELY',\n  'RENT', 'REST', 'RICE', 'RICH', 'RIDE', 'RIFF', 'RIFT', 'RING', 'RIOT',\n  'RIPE', 'RISE', 'RISK', 'ROAD', 'ROAM', 'ROAR', 'ROBE', 'ROCK', 'RODE',\n  'ROLE', 'ROLL', 'ROOF', 'ROOM', 'ROOT', 'ROPE', 'ROSE', 'ROSY', 'ROUT',\n  'RUDE', 'RUIN', 'RULE', 'RUMP', 'RUNG', 'RUNS', 'RUSH', 'RUST', 'SACK',\n  'SAFE', 'SAGE', 'SAID', 'SAIL', 'SAKE', 'SALE', 'SALT', 'SAME', 'SAND',\n  'SANE', 'SANG', 'SANK', 'SAVE', 'SAYS', 'SCAN', 'SCAR', 'SEAL', 'SEAM',\n  'SEAT', 'SECT', 'SEED', 'SEEK', 'SEEM', 'SEEN', 'SELF', 'SELL', 'SEND',\n  'SENT', 'SHED', 'SHIP', 'SHOP', 'SHOT', 'SHOW', 'SHUT', 'SICK', 'SIDE',\n  'SIFT', 'SIGH', 'SIGN', 'SILK', 'SING', 'SINK', 'SITE', 'SIZE', 'SKIM',\n  'SKIN', 'SKIP', 'SLAB', 'SLAM', 'SLAP', 'SLAT', 'SLED', 'SLEW', 'SLID',\n  'SLIM', 'SLIP', 'SLIT', 'SLOT', 'SLOW', 'SLUG', 'SLUM', 'SNAP', 'SNOB',\n  'SNOW', 'SNUB', 'SNUG', 'SOAK', 'SOAP', 'SOAR', 'SOCK', 'SODA', 'SOFA',\n  'SOFT', 'SOIL', 'SOLD', 'SOLE', 'SOME', 'SONG', 'SOON', 'SOOT', 'SORE',\n  'SORT', 'SOUL', 'SOUP', 'SOUR', 'SPAN', 'SPAR', 'SPEC', 'SPED', 'SPIN',\n  'SPIT', 'SPOT', 'SPUN', 'SPUR', 'STAB', 'STAG', 'STAR', 'STAY', 'STEM',\n  'STEP', 'STEW', 'STIR', 'STOP', 'STUB', 'STUD', 'STUN', 'SUCH', 'SUIT',\n  'SULK', 'SUNG', 'SUNK', 'SURE', 'SURF', 'SWAN', 'SWAP', 'SWIM', 'TACK',\n  'TAIL', 'TAKE', 'TALE', 'TALK', 'TALL', 'TAME', 'TANK', 'TAPE', 'TAPS',\n  'TASK', 'TAXI', 'TEAM', 'TEAR', 'TELL', 'TEND', 'TENT', 'TERM', 'TEST',\n  'TEXT', 'THAN', 'THAT', 'THEM', 'THEN', 'THEY', 'THIN', 'THIS', 'THUS',\n  'TICK', 'TIDE', 'TIDY', 'TIED', 'TIER', 'TIES', 'TILE', 'TILL', 'TILT',\n  'TIME', 'TINT', 'TINY', 'TIPS', 'TIRE', 'TOAD', 'TOES', 'TOIL', 'TOLD',\n  'TOLL', 'TOMB', 'TONE', 'TONS', 'TOOK', 'TOOL', 'TOPS', 'TORE', 'TORN',\n  'TORT', 'TOSS', 'TOUR', 'TOWN', 'TRAP', 'TRAY', 'TREE', 'TREK', 'TRIM',\n  'TRIO', 'TRIP', 'TROD', 'TROT', 'TRUE', 'TUBE', 'TUCK', 'TUFT', 'TUNE',\n  'TURN', 'TWIN', 'TYPE', 'UGLY', 'UNDO', 'UNIT', 'UPON', 'URGE', 'USED',\n  'USER', 'VAIN', 'VALE', 'VANE', 'VARY', 'VASE', 'VAST', 'VEAL', 'VEIN',\n  'VENT', 'VERB', 'VERY', 'VEST', 'VETO', 'VICE', 'VIEW', 'VINE', 'VISA',\n  'VOID', 'VOLT', 'VOTE', 'WADE', 'WAGE', 'WAIT', 'WAKE', 'WALK', 'WALL',\n  'WAND', 'WANT', 'WARD', 'WARM', 'WARN', 'WARP', 'WART', 'WARY', 'WASH',\n  'WASP', 'WAVE', 'WAVY', 'WAXY', 'WAYS', 'WEAK', 'WEAR', 'WEBS', 'WEED',\n  'WEEK', 'WEEP', 'WELD', 'WELL', 'WENT', 'WEPT', 'WERE', 'WEST', 'WHAT',\n  'WHEN', 'WICK', 'WIDE', 'WIFE', 'WILD', 'WILL', 'WILT', 'WIMP', 'WIND',\n  'WINE', 'WING', 'WINK', 'WINS', 'WIPE', 'WIRE', 'WISE', 'WISH', 'WITH',\n  'WOKE', 'WOLF', 'WOMB', 'WONT', 'WOOD', 'WOOL', 'WORD', 'WORE', 'WORK',\n  'WORM', 'WORN', 'WRAP', 'YARD', 'YARN', 'YAWN', 'YEAR', 'YELL', 'YOUR',\n  'ZEAL', 'ZERO', 'ZEST', 'ZINC', 'ZONE', 'ZOOM',\n];\n\n// 5-letter words (~150 words)\nconst FIVE_LETTER_WORDS: string[] = [\n  'ABOVE', 'ABUSE', 'ACTOR', 'ADMIT', 'ADOPT', 'ADULT', 'AFTER', 'AGAIN',\n  'AGENT', 'AGREE', 'AHEAD', 'ALARM', 'ALBUM', 'ALERT', 'ALIEN', 'ALIGN',\n  'ALIKE', 'ALIVE', 'ALLOW', 'ALONE', 'ALONG', 'ALTAR', 'ALTER', 'AMONG',\n  'ANGEL', 'ANGLE', 'ANGRY', 'ANKLE', 'APART', 'APPLE', 'APPLY', 'ARENA',\n  'ARGUE', 'ARISE', 'ARMOR', 'AROMA', 'ARRAY', 'ARROW', 'ASSET', 'AUDIO',\n  'AVOID', 'AWARD', 'AWARE', 'AWFUL', 'BACON', 'BADGE', 'BADLY', 'BAKER',\n  'BASIC', 'BASIN', 'BASIS', 'BATCH', 'BEACH', 'BEAST', 'BEGAN', 'BEGIN',\n  'BEING', 'BELOW', 'BENCH', 'BERRY', 'BIBLE', 'BIRTH', 'BLACK', 'BLADE',\n  'BLAME', 'BLANK', 'BLAST', 'BLEND', 'BLESS', 'BLIND', 'BLOCK', 'BLOOD',\n  'BLOOM', 'BLOWN', 'BOARD', 'BOAST', 'BONUS', 'BOOTH', 'BRAIN', 'BRAKE',\n  'BRAND', 'BRASS', 'BRAVE', 'BREAD', 'BREAK', 'BRICK', 'BRIDE', 'BRIEF',\n  'BRING', 'BROAD', 'BROKE', 'BROOK', 'BROWN', 'BRUSH', 'BUILD', 'BUNCH',\n  'BURNT', 'BURST', 'BUYER', 'CABIN', 'CABLE', 'CAMEL', 'CANDY', 'CARGO',\n  'CARRY', 'CARVE', 'CATCH', 'CAUSE', 'CHAIN', 'CHAIR', 'CHALK', 'CHAMP',\n  'CHARM', 'CHART', 'CHASE', 'CHEAP', 'CHECK', 'CHEEK', 'CHEER', 'CHESS',\n  'CHEST', 'CHILD', 'CHILL', 'CHINA', 'CHOIR', 'CHORD', 'CHOSE', 'CIGAR',\n  'CIRCA', 'CIVIL', 'CLAIM', 'CLASS', 'CLEAN', 'CLEAR', 'CLERK', 'CLICK',\n  'CLIFF', 'CLIMB', 'CLING', 'CLOCK', 'CLOSE', 'CLOTH', 'CLOUD', 'CLOWN',\n  'COACH', 'COAST', 'COLON', 'COLOR', 'CORAL', 'COUCH', 'COULD', 'COUNT',\n  'COURT', 'COVER', 'CRACK', 'CRAFT', 'CRANE', 'CRASH', 'CRAWL', 'CRAZY',\n  'CREAM', 'CREEK', 'CREST', 'CRIME', 'CRISP', 'CROSS', 'CROWD', 'CROWN',\n  'CRUDE', 'CRUEL', 'CRUSH', 'CUBIC', 'CURVE', 'CYBER', 'CYCLE', 'DAIRY',\n  'DANCE', 'DEALT', 'DEATH', 'DEBUT', 'DECAY', 'DELTA', 'DENSE', 'DEPOT',\n  'DEPTH', 'DERBY', 'DIARY', 'DIGIT', 'DIRTY', 'DISCO', 'DITCH', 'DOUBT',\n  'DOUGH', 'DOZEN', 'DRAFT', 'DRAIN', 'DRAMA', 'DRANK', 'DRAWL', 'DRAWN',\n  'DREAD', 'DREAM', 'DRESS', 'DRIED', 'DRIFT', 'DRILL', 'DRINK', 'DRIVE',\n  'DROWN', 'DYING', 'EAGER', 'EARLY', 'EARTH', 'EIGHT', 'ELBOW', 'ELDER',\n  'ELECT', 'ELITE', 'EMPTY', 'ENEMY', 'ENJOY', 'ENTER', 'ENTRY', 'EQUAL',\n  'EQUIP', 'ERROR', 'ESSAY', 'ETHIC', 'EVADE', 'EVENT', 'EVERY', 'EXACT',\n  'EXCEL', 'EXILE', 'EXIST', 'EXTRA', 'FAINT', 'FAIRY', 'FAITH', 'FALSE',\n  'FANCY', 'FATAL', 'FAULT', 'FAVOR', 'FEAST', 'FENCE', 'FERRY', 'FETCH',\n  'FEVER', 'FIBER', 'FIELD', 'FIFTY', 'FIGHT', 'FINAL', 'FIRST', 'FIXED',\n  'FLAME', 'FLASH', 'FLASK', 'FLEET', 'FLESH', 'FLOAT', 'FLOCK', 'FLOOD',\n  'FLOOR', 'FLORA', 'FLOUR', 'FLUID', 'FLUSH', 'FOCUS', 'FORCE', 'FORGE',\n  'FORTH', 'FORTY', 'FORUM', 'FOUND', 'FRAME', 'FRANK', 'FRAUD', 'FRESH',\n  'FRONT', 'FROST', 'FRUIT', 'FULLY', 'FUNNY', 'GHOST', 'GIANT', 'GIVEN',\n  'GLAND', 'GLASS', 'GLEAM', 'GLIDE', 'GLOBE', 'GLOOM', 'GLORY', 'GLOVE',\n  'GOOSE', 'GRACE', 'GRADE', 'GRAIN', 'GRAND', 'GRANT', 'GRAPE', 'GRAPH',\n  'GRASP', 'GRASS', 'GRAVE', 'GREED', 'GREEN', 'GREET', 'GRIEF', 'GRILL',\n  'GRIND', 'GROAN', 'GROOM', 'GROSS', 'GROUP', 'GROVE', 'GROWL', 'GROWN',\n  'GUARD', 'GUESS', 'GUEST', 'GUIDE', 'GUILD', 'GUILT', 'HABIT', 'HANDY',\n  'HAPPY', 'HARSH', 'HASTE', 'HAVEN', 'HEART', 'HEAVY', 'HEDGE', 'HELLO',\n  'HENCE', 'HERBS', 'HINGE', 'HOBBY', 'HONOR', 'HORSE', 'HOTEL', 'HOUND',\n  'HOUSE', 'HUMAN', 'HUMID', 'HUMOR', 'HURRY', 'IDEAL', 'IMAGE', 'IMPLY',\n  'INDEX', 'INNER', 'INPUT', 'INTEL', 'INTER', 'INTRO', 'IRONY', 'ISSUE',\n  'IVORY', 'JELLY', 'JEWEL', 'JOINT', 'JOKER', 'JUDGE', 'JUICE', 'JUICY',\n  'JUMBO', 'JUMPY', 'KIOSK', 'KNIFE', 'KNOCK', 'LABEL', 'LABOR', 'LARGE',\n  'LASER', 'LATER', 'LAUGH', 'LAYER', 'LEARN', 'LEASE', 'LEAST', 'LEAVE',\n  'LEGAL', 'LEMON', 'LEVEL', 'LEVER', 'LIGHT', 'LIMIT', 'LINEN', 'LINER',\n  'LIVER', 'LOBBY', 'LOCAL', 'LODGE', 'LOGIC', 'LOOSE', 'LORRY', 'LOTUS',\n  'LOUSY', 'LOVER', 'LOWER', 'LOYAL', 'LUCKY', 'LUNAR', 'LUNCH', 'MAGIC',\n  'MAGMA', 'MAJOR', 'MAKER', 'MANOR', 'MARCH', 'MARRY', 'MARSH', 'MATCH',\n  'MAYOR', 'MEDAL', 'MEDIA', 'MELON', 'MERCY', 'MERGE', 'MERIT', 'MERRY',\n  'METAL', 'METER', 'MICRO', 'MIDST', 'MIGHT', 'MINOR', 'MINUS', 'MIRTH',\n  'MIXER', 'MODEL', 'MODEM', 'MONEY', 'MONTH', 'MORAL', 'MOTOR', 'MOUND',\n  'MOUNT', 'MOUSE', 'MOUTH', 'MOVIE', 'MUDDY', 'MUSIC', 'NAIVE', 'NAKED',\n  'NASTY', 'NAVAL', 'NERVE', 'NEVER', 'NIGHT', 'NINTH', 'NOBLE', 'NOISE',\n  'NORTH', 'NOTCH', 'NOTED', 'NOVEL', 'NURSE', 'OCCUR', 'OCEAN', 'OFFER',\n  'OFTEN', 'OLIVE', 'OMEGA', 'ONION', 'ONSET', 'OPERA', 'ORBIT', 'ORDER',\n  'ORGAN', 'OTHER', 'OUGHT', 'OUTER', 'OWNED', 'OWNER', 'OXIDE', 'OZONE',\n  'PAINT', 'PANEL', 'PANIC', 'PAPER', 'PARTY', 'PASTA', 'PATCH', 'PAUSE',\n  'PEACE', 'PEACH', 'PEARL', 'PEDAL', 'PENNY', 'PERCH', 'PHASE', 'PHONE',\n  'PHOTO', 'PIANO', 'PIECE', 'PILOT', 'PINCH', 'PITCH', 'PIXEL', 'PIZZA',\n  'PLACE', 'PLAIN', 'PLANE', 'PLANT', 'PLATE', 'PLAZA', 'PLEAD', 'PLUCK',\n  'PLUMB', 'PLUMP', 'PLUNGE', 'POINT', 'POLAR', 'PORCH', 'POUCH', 'POUND',\n  'POWER', 'PRESS', 'PRICE', 'PRIDE', 'PRIME', 'PRINT', 'PRIOR', 'PRIZE',\n  'PROBE', 'PRONE', 'PROOF', 'PROUD', 'PROVE', 'PROXY', 'PUNCH', 'PUPIL',\n  'PUPPY', 'PURSE', 'QUAKE', 'QUEEN', 'QUERY', 'QUEST', 'QUICK', 'QUIET',\n  'QUITE', 'QUOTA', 'QUOTE', 'RADAR', 'RADIO', 'RAISE', 'RALLY', 'RANCH',\n  'RANGE', 'RAPID', 'RATIO', 'REACH', 'REACT', 'READY', 'REALM', 'REBEL',\n  'REFER', 'REIGN', 'RELAX', 'RELAY', 'RELY', 'REPLY', 'RESET', 'RIDER',\n  'RIDGE', 'RIFLE', 'RIGHT', 'RIGID', 'RIPEN', 'RISEN', 'RISKY', 'RIVAL',\n  'RIVER', 'ROAST', 'ROBOT', 'ROCKY', 'ROMAN', 'ROUGH', 'ROUND', 'ROUTE',\n  'ROYAL', 'RUGBY', 'RULER', 'RUMOR', 'RURAL', 'SAFER', 'SAINT', 'SALAD',\n  'SALON', 'SANDY', 'SAUCE', 'SAUNA', 'SCALE', 'SCARE', 'SCARF', 'SCARY',\n  'SCENE', 'SCENT', 'SCOPE', 'SCORE', 'SCOUT', 'SCRAP', 'SEIZE', 'SERVE',\n  'SETUP', 'SEVEN', 'SHADE', 'SHAKE', 'SHALL', 'SHAME', 'SHAPE', 'SHARE',\n  'SHARK', 'SHARP', 'SHAVE', 'SHEEP', 'SHEER', 'SHEET', 'SHELF', 'SHELL',\n  'SHIFT', 'SHINE', 'SHINY', 'SHIRT', 'SHOCK', 'SHORE', 'SHORT', 'SHOUT',\n  'SHOWN', 'SHRUG', 'SIGHT', 'SIGMA', 'SILKY', 'SILLY', 'SINCE', 'SIXTY',\n  'SIZED', 'SKILL', 'SKULL', 'SLAVE', 'SLEEP', 'SLICE', 'SLIDE', 'SLOPE',\n  'SMALL', 'SMART', 'SMELL', 'SMILE', 'SMOKE', 'SNAKE', 'SNOWY', 'SOBER',\n  'SOLID', 'SOLVE', 'SONIC', 'SORRY', 'SOUND', 'SOUTH', 'SPACE', 'SPARE',\n  'SPARK', 'SPEAK', 'SPEAR', 'SPEED', 'SPELL', 'SPEND', 'SPICE', 'SPICY',\n  'SPIKE', 'SPILL', 'SPINE', 'SPOIL', 'SPOKE', 'SPOON', 'SPORT', 'SPRAY',\n  'SQUAD', 'STACK', 'STAFF', 'STAGE', 'STAIN', 'STAIR', 'STAKE', 'STALE',\n  'STAMP', 'STAND', 'STARK', 'START', 'STATE', 'STEAK', 'STEAL', 'STEAM',\n  'STEEL', 'STEEP', 'STEER', 'STICK', 'STIFF', 'STILL', 'STOCK', 'STONE',\n  'STOOL', 'STORE', 'STORM', 'STORY', 'STOVE', 'STRAP', 'STRAW', 'STRIP',\n  'STUCK', 'STUDY', 'STUFF', 'STUNT', 'STYLE', 'SUGAR', 'SUITE', 'SUNNY',\n  'SUPER', 'SURGE', 'SWAMP', 'SWEAR', 'SWEAT', 'SWEET', 'SWEPT', 'SWIFT',\n  'SWING', 'SWORD', 'TABLE', 'TAKEN', 'TASTE', 'TASTY', 'TEACH', 'TEMPO',\n  'TENSE', 'TENTH', 'TERMS', 'THANK', 'THEME', 'THICK', 'THIEF', 'THING',\n  'THINK', 'THIRD', 'THORN', 'THOSE', 'THREE', 'THREW', 'THROW', 'THUMB',\n  'TIGER', 'TIGHT', 'TIMER', 'TIRED', 'TITLE', 'TOAST', 'TODAY', 'TOKEN',\n  'TONIC', 'TOOTH', 'TOPIC', 'TORCH', 'TOTAL', 'TOUCH', 'TOUGH', 'TOWER',\n  'TOXIC', 'TRACE', 'TRACK', 'TRADE', 'TRAIL', 'TRAIN', 'TRAIT', 'TRASH',\n  'TREAT', 'TREND', 'TRIAL', 'TRIBE', 'TRICK', 'TRIED', 'TROOP', 'TRUCK',\n  'TRULY', 'TRUMP', 'TRUNK', 'TRUST', 'TRUTH', 'TUMOR', 'TUNER', 'TWICE',\n  'TWIST', 'ULTRA', 'UNCLE', 'UNDER', 'UNFAIR', 'UNION', 'UNITE', 'UNITY',\n  'UNTIL', 'UPPER', 'UPSET', 'URBAN', 'USAGE', 'USUAL', 'VALID', 'VALUE',\n  'VALVE', 'VAULT', 'VENUE', 'VIDEO', 'VIGOR', 'VIRAL', 'VIRUS', 'VISIT',\n  'VITAL', 'VIVID', 'VOCAL', 'VOICE', 'VOTER', 'WAGON', 'WAIST', 'WASTE',\n  'WATCH', 'WATER', 'WEARY', 'WEIGH', 'WEIRD', 'WHALE', 'WHEAT', 'WHEEL',\n  'WHERE', 'WHICH', 'WHILE', 'WHITE', 'WHOLE', 'WHOSE', 'WIDER', 'WIDOW',\n  'WIDTH', 'WIPER', 'WITCH', 'WOMAN', 'WOODS', 'WORLD', 'WORMS', 'WORRY',\n  'WORSE', 'WORST', 'WORTH', 'WOULD', 'WOUND', 'WRIST', 'WRITE', 'WRONG',\n  'WROTE', 'YACHT', 'YIELD', 'YOUNG', 'YOURS', 'YOUTH', 'ZEBRA', 'ZONAL',\n];\n\nexport const WORD_LISTS: WordLists = {\n  3: THREE_LETTER_WORDS,\n  4: FOUR_LETTER_WORDS,\n  5: FIVE_LETTER_WORDS,\n};\n\n/**\n * Get all words of a specific length\n */\nexport function getWordsByLength(length: WordLength): string[] {\n  return WORD_LISTS[length];\n}\n\n/**\n * Get characters contained in a word\n */\nexport function getWordCharacters(word: string): string[] {\n  return word.toUpperCase().split('');\n}\n\n/**\n * Filter words to only those containing characters from the active set\n */\nexport function filterWordsByActiveChars(\n  words: string[],\n  activeChars: string[]\n): string[] {\n  const activeSet = new Set(activeChars.map(c => c.toUpperCase()));\n  return words.filter(word =>\n    word.split('').every(char => activeSet.has(char))\n  );\n}\n","import type { WordHistoryState } from '../types';\nimport { getDefaultWMA } from './weighted-average';\nimport { getWordsByLength, filterWordsByActiveChars, type WordLength } from '../data/word-lists';\n\n/**\n * Calculate a word's \"weakness score\" based on constituent character WMAs.\n * Higher score = word contains weaker characters = should be practiced more.\n */\nexport function calculateWordWeakness(\n  word: string,\n  wordHistory: WordHistoryState\n): number {\n  const chars = word.toUpperCase().split('');\n  const defaultWMA = getDefaultWMA();\n\n  // Sum of WMAs for all characters in the word\n  const totalWMA = chars.reduce((sum, char) => {\n    const wma = wordHistory[char]?.wma ?? defaultWMA;\n    return sum + wma;\n  }, 0);\n\n  // Average WMA for the word\n  return totalWMA / chars.length;\n}\n\n/**\n * Adaptive word selection algorithm\n * Words containing characters with higher (slower) WMA get higher selection probability\n * Adaptive gain controls how much the distribution is skewed toward weak words\n */\nexport function selectNextWord(\n  wordLength: WordLength,\n  wordHistory: WordHistoryState,\n  activeChars: string[],\n  adaptiveGain: number = 50,\n  previousWord: string | null = null\n): string {\n  const allWords = getWordsByLength(wordLength);\n  const validWords = filterWordsByActiveChars(allWords, activeChars);\n\n  if (validWords.length === 0) {\n    throw new Error('No valid words available with current character set');\n  }\n\n  if (validWords.length === 1) {\n    return validWords[0];\n  }\n\n  // Calculate weights for each word based on average character weakness\n  const weights = validWords.map((word) => {\n    const weakness = calculateWordWeakness(word, wordHistory);\n\n    // Adaptive gain transforms the distribution:\n    // gain = 0: flat distribution (all equal weight)\n    // gain = 50: linear relationship to weakness\n    // gain = 100: squared relationship (heavily favor weak words)\n    const exponent = adaptiveGain / 50; // 0 to 2\n    let weight = Math.pow(weakness / 1000, exponent); // Normalize to reasonable range\n\n    // Reduce weight of previous word to avoid immediate repeats\n    if (word === previousWord) {\n      weight *= 0.2;\n    }\n\n    return { word, weight };\n  });\n\n  // Calculate total weight for normalization\n  const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);\n\n  // Random selection based on weighted probabilities\n  const random = Math.random() * totalWeight;\n  let cumulative = 0;\n\n  for (const { word, weight } of weights) {\n    cumulative += weight;\n    if (random <= cumulative) {\n      return word;\n    }\n  }\n\n  // Fallback (should rarely happen due to floating point)\n  return weights[weights.length - 1].word;\n}\n\n/**\n * Get the selection probability for each word (for debugging/visualization)\n */\nexport function getWordSelectionProbabilities(\n  wordLength: WordLength,\n  wordHistory: WordHistoryState,\n  activeChars: string[],\n  adaptiveGain: number = 50\n): Array<{ word: string; probability: number; avgWMA: number }> {\n  const allWords = getWordsByLength(wordLength);\n  const validWords = filterWordsByActiveChars(allWords, activeChars);\n\n  if (validWords.length === 0) return [];\n\n  const exponent = adaptiveGain / 50;\n\n  const weights = validWords.map((word) => {\n    const avgWMA = calculateWordWeakness(word, wordHistory);\n    const weight = Math.pow(avgWMA / 1000, exponent);\n    return { word, weight, avgWMA };\n  });\n\n  const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);\n\n  return weights.map(({ word, weight, avgWMA }) => ({\n    word,\n    probability: weight / totalWeight,\n    avgWMA,\n  }));\n}\n\n/**\n * Check if word mode is available with current character set\n * Returns true if at least one word can be formed\n */\nexport function isWordModeAvailable(\n  wordLength: WordLength,\n  activeChars: string[]\n): boolean {\n  const allWords = getWordsByLength(wordLength);\n  const validWords = filterWordsByActiveChars(allWords, activeChars);\n  return validWords.length > 0;\n}\n\n/**\n * Get count of available words for a given length and character set\n */\nexport function getAvailableWordCount(\n  wordLength: WordLength,\n  activeChars: string[]\n): number {\n  const allWords = getWordsByLength(wordLength);\n  const validWords = filterWordsByActiveChars(allWords, activeChars);\n  return validWords.length;\n}\n","import { store } from '../state/store';\nimport type { PracticeMode } from '../types';\nimport { getAvailableWordCount, isWordModeAvailable } from '../core/word-selector';\nimport type { WordLength } from '../data/word-lists';\n\nexport class ModeSelector {\n  private charModeBtn: HTMLButtonElement;\n  private wordModeBtn: HTMLButtonElement;\n  private callsignModeBtn: HTMLButtonElement;\n  private wordLengthControl: HTMLElement;\n  private wordLengthSlider: HTMLInputElement;\n  private wordLengthValue: HTMLElement;\n  private wordCountInfo: HTMLElement;\n  private callsignFormatControl: HTMLElement;\n  private callsignFormatInfo: HTMLElement;\n  private formatCheckboxes: NodeListOf<HTMLInputElement>;\n\n  // Callback when mode or length changes (to stop active sessions)\n  private onModeChange: ((mode: PracticeMode) => void) | null = null;\n  // Callback to sync chart with mode\n  private onChartToggle: ((mode: PracticeMode) => void) | null = null;\n\n  constructor() {\n    // Get DOM elements\n    this.charModeBtn = document.getElementById('char-mode-btn') as HTMLButtonElement;\n    this.wordModeBtn = document.getElementById('word-mode-btn') as HTMLButtonElement;\n    this.callsignModeBtn = document.getElementById('callsign-mode-btn') as HTMLButtonElement;\n    this.wordLengthControl = document.getElementById('word-length-control') as HTMLElement;\n    this.wordLengthSlider = document.getElementById('word-length-slider') as HTMLInputElement;\n    this.wordLengthValue = document.getElementById('word-length-value') as HTMLElement;\n    this.wordCountInfo = document.getElementById('word-count-info') as HTMLElement;\n    this.callsignFormatControl = document.getElementById('callsign-format-control') as HTMLElement;\n    this.callsignFormatInfo = document.getElementById('callsign-format-info') as HTMLElement;\n    this.formatCheckboxes = document.querySelectorAll('.format-checkbox input[type=\"checkbox\"]');\n\n    this.setupEventListeners();\n    this.initializeFromState();\n  }\n\n  private setupEventListeners(): void {\n    this.charModeBtn.addEventListener('click', () => this.setMode('character'));\n    this.wordModeBtn.addEventListener('click', () => this.setMode('word'));\n    this.callsignModeBtn.addEventListener('click', () => this.setMode('callsign'));\n\n    this.wordLengthSlider.addEventListener('input', () => {\n      const length = parseInt(this.wordLengthSlider.value) as WordLength;\n      this.wordLengthValue.textContent = length.toString();\n      store.updateWordModeSettings({ wordLength: length });\n      this.updateWordCountInfo(length);\n\n      // Changing length should stop active session and trigger callback\n      if (this.onModeChange) {\n        this.onModeChange('word');\n      }\n    });\n\n    // Callsign format checkboxes\n    this.formatCheckboxes.forEach(checkbox => {\n      checkbox.addEventListener('change', () => {\n        this.updateCallsignFormats();\n        // Changing formats should stop active session\n        if (this.onModeChange) {\n          this.onModeChange('callsign');\n        }\n      });\n    });\n\n    // Subscribe to character set changes to update word count\n    store.subscribe('characterSet', () => {\n      const settings = store.getWordModeSettings();\n      if (settings.practiceMode === 'word') {\n        this.updateWordCountInfo(settings.wordLength);\n      }\n    });\n  }\n\n  private initializeFromState(): void {\n    const settings = store.getWordModeSettings();\n    const callsignSettings = store.getCallsignModeSettings();\n\n    // Initialize callsign format checkboxes from stored state\n    this.formatCheckboxes.forEach(checkbox => {\n      checkbox.checked = callsignSettings.enabledFormats.includes(checkbox.value);\n    });\n\n    this.updateUI(settings.practiceMode, settings.wordLength);\n    this.updateCallsignFormatInfo();\n  }\n\n  private setMode(mode: PracticeMode): void {\n    store.updateWordModeSettings({ practiceMode: mode });\n    this.updateUI(mode, store.getWordModeSettings().wordLength);\n\n    if (this.onModeChange) {\n      this.onModeChange(mode);\n    }\n\n    // Sync chart with mode\n    if (this.onChartToggle) {\n      this.onChartToggle(mode);\n    }\n  }\n\n  private updateUI(mode: PracticeMode, wordLength: WordLength): void {\n    // Update button states\n    this.charModeBtn.classList.toggle('active', mode === 'character');\n    this.wordModeBtn.classList.toggle('active', mode === 'word');\n    this.callsignModeBtn.classList.toggle('active', mode === 'callsign');\n\n    // Show/hide word length control\n    this.wordLengthControl.classList.toggle('hidden', mode !== 'word');\n\n    // Show/hide callsign format control\n    this.callsignFormatControl.classList.toggle('hidden', mode !== 'callsign');\n\n    // Update slider\n    this.wordLengthSlider.value = wordLength.toString();\n    this.wordLengthValue.textContent = wordLength.toString();\n\n    // Update word count info if in word mode\n    if (mode === 'word') {\n      this.updateWordCountInfo(wordLength);\n    }\n\n    // Update callsign format info if in callsign mode\n    if (mode === 'callsign') {\n      this.updateCallsignFormatInfo();\n    }\n  }\n\n  private updateWordCountInfo(wordLength: WordLength): void {\n    const activeChars = store.getActiveCharacters();\n    const count = getAvailableWordCount(wordLength, activeChars);\n    const available = isWordModeAvailable(wordLength, activeChars);\n\n    if (!available) {\n      this.wordCountInfo.textContent = 'No words available with current character set';\n      this.wordCountInfo.classList.add('warning');\n    } else {\n      this.wordCountInfo.textContent = `${count} words available`;\n      this.wordCountInfo.classList.remove('warning');\n    }\n  }\n\n  private updateCallsignFormats(): void {\n    const enabledFormats: string[] = [];\n    this.formatCheckboxes.forEach(checkbox => {\n      if (checkbox.checked) {\n        enabledFormats.push(checkbox.value);\n      }\n    });\n    store.updateCallsignModeSettings({ enabledFormats });\n    this.updateCallsignFormatInfo();\n  }\n\n  private updateCallsignFormatInfo(): void {\n    const callsignSettings = store.getCallsignModeSettings();\n    const enabledCount = callsignSettings.enabledFormats.length;\n\n    if (enabledCount === 0) {\n      this.callsignFormatInfo.textContent = 'Select at least one format';\n      this.callsignFormatInfo.classList.add('warning');\n    } else {\n      // Show example callsign for the selected formats\n      const examples: Record<string, string> = {\n        '1x1': 'K1A',\n        '1x2': 'W3AB',\n        '2x1': 'KA5X',\n        '2x2': 'WB2XY',\n        '1x3': 'N7ABC',\n        '2x3': 'KE9BOS',\n      };\n      const exampleList = callsignSettings.enabledFormats\n        .slice(0, 3)\n        .map(f => examples[f])\n        .join(', ');\n      const suffix = enabledCount > 3 ? '...' : '';\n      this.callsignFormatInfo.textContent = `e.g., ${exampleList}${suffix}`;\n      this.callsignFormatInfo.classList.remove('warning');\n    }\n  }\n\n  setOnModeChange(callback: (mode: PracticeMode) => void): void {\n    this.onModeChange = callback;\n  }\n\n  setOnChartToggle(callback: (mode: PracticeMode) => void): void {\n    this.onChartToggle = callback;\n  }\n\n  getCurrentMode(): PracticeMode {\n    return store.getWordModeSettings().practiceMode;\n  }\n\n  getCurrentWordLength(): WordLength {\n    return store.getWordModeSettings().wordLength;\n  }\n}\n","import type { HistoryState } from '../types';\nimport { getDefaultWMA } from './weighted-average';\n\n/**\n * Adaptive character selection algorithm\n * Characters with higher (slower) WMA get higher selection probability\n * Adaptive gain controls how much the distribution is skewed toward slow characters\n */\nexport function selectNextCharacter(\n  activeChars: string[],\n  history: HistoryState,\n  adaptiveGain: number = 50,\n  previousChar: string | null = null\n): string {\n  if (activeChars.length === 0) {\n    throw new Error('No active characters to select from');\n  }\n\n  if (activeChars.length === 1) {\n    return activeChars[0];\n  }\n\n  const defaultWMA = getDefaultWMA();\n\n  // Calculate weights for each character\n  const weights = activeChars.map((char) => {\n    const wma = history[char]?.wma ?? defaultWMA;\n\n    // Adaptive gain transforms the distribution:\n    // gain = 0: flat distribution (all equal weight)\n    // gain = 50: linear relationship to WMA\n    // gain = 100: squared relationship (heavily favor slow chars)\n    const exponent = adaptiveGain / 50; // 0 to 2\n    let weight = Math.pow(wma / 1000, exponent); // Normalize WMA to reasonable range\n\n    // Reduce weight of previous character to avoid immediate repeats\n    if (char === previousChar) {\n      weight *= 0.2;\n    }\n\n    return { char, weight };\n  });\n\n  // Calculate total weight for normalization\n  const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);\n\n  // Random selection based on weighted probabilities\n  const random = Math.random() * totalWeight;\n  let cumulative = 0;\n\n  for (const { char, weight } of weights) {\n    cumulative += weight;\n    if (random <= cumulative) {\n      return char;\n    }\n  }\n\n  // Fallback (should rarely happen due to floating point)\n  return weights[weights.length - 1].char;\n}\n\n/**\n * Get the selection probability for each character (for debugging/visualization)\n */\nexport function getSelectionProbabilities(\n  activeChars: string[],\n  history: HistoryState,\n  adaptiveGain: number = 50\n): Array<{ char: string; probability: number }> {\n  if (activeChars.length === 0) return [];\n\n  const defaultWMA = getDefaultWMA();\n  const exponent = adaptiveGain / 50;\n\n  const weights = activeChars.map((char) => {\n    const wma = history[char]?.wma ?? defaultWMA;\n    const weight = Math.pow(wma / 1000, exponent);\n    return { char, weight };\n  });\n\n  const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);\n\n  return weights.map(({ char, weight }) => ({\n    char,\n    probability: weight / totalWeight,\n  }));\n}\n","import type { CallsignHistoryState } from '../types';\nimport { getDefaultWMA } from './weighted-average';\n\n// Callsign format definitions\nexport interface CallsignFormat {\n  id: string;           // '1x1', '1x2', etc.\n  name: string;         // Display name\n  prefixLength: 1 | 2;\n  suffixLength: 1 | 2 | 3;\n}\n\nexport const CALLSIGN_FORMATS: CallsignFormat[] = [\n  { id: '1x1', name: '1×1 (e.g., K1A)', prefixLength: 1, suffixLength: 1 },\n  { id: '1x2', name: '1×2 (e.g., W3AB)', prefixLength: 1, suffixLength: 2 },\n  { id: '2x1', name: '2×1 (e.g., KA5X)', prefixLength: 2, suffixLength: 1 },\n  { id: '2x2', name: '2×2 (e.g., WB2XY)', prefixLength: 2, suffixLength: 2 },\n  { id: '1x3', name: '1×3 (e.g., N7ABC)', prefixLength: 1, suffixLength: 3 },\n  { id: '2x3', name: '2×3 (e.g., KE9BOS)', prefixLength: 2, suffixLength: 3 },\n];\n\n// Valid first letters for US amateur callsigns\nconst US_PREFIX_FIRST = ['K', 'N', 'W', 'A'];\n\n// All letters for suffix and second prefix position\nconst ALL_LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n\n// Digits 0-9\nconst DIGITS = '0123456789'.split('');\n\n/**\n * Get format by ID\n */\nexport function getFormatById(id: string): CallsignFormat | undefined {\n  return CALLSIGN_FORMATS.find(f => f.id === id);\n}\n\n/**\n * Get formats by IDs\n */\nexport function getFormatsByIds(ids: string[]): CallsignFormat[] {\n  return CALLSIGN_FORMATS.filter(f => ids.includes(f.id));\n}\n\n/**\n * Select a character based on weighted probabilities\n * Higher WMA (slower response) = higher chance of selection\n */\nfunction selectWeightedChar(\n  candidates: string[],\n  callsignHistory: CallsignHistoryState,\n  adaptiveGain: number\n): string {\n  if (candidates.length === 0) {\n    throw new Error('No candidates for weighted selection');\n  }\n\n  if (candidates.length === 1 || adaptiveGain === 0) {\n    // Random selection when no gain or single candidate\n    return candidates[Math.floor(Math.random() * candidates.length)];\n  }\n\n  const defaultWMA = getDefaultWMA();\n  const exponent = adaptiveGain / 50; // 0 to 2\n\n  // Calculate weight for each candidate\n  const weights = candidates.map(char => {\n    const wma = callsignHistory[char]?.wma ?? defaultWMA;\n    const weight = Math.pow(wma / 1000, exponent);\n    return { char, weight };\n  });\n\n  // Calculate total weight\n  const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);\n\n  // Random selection based on weighted probabilities\n  const random = Math.random() * totalWeight;\n  let cumulative = 0;\n\n  for (const { char, weight } of weights) {\n    cumulative += weight;\n    if (random <= cumulative) {\n      return char;\n    }\n  }\n\n  // Fallback\n  return weights[weights.length - 1].char;\n}\n\n/**\n * Generate a realistic US amateur callsign with adaptive character weighting\n *\n * @param format - The callsign format to generate\n * @param callsignHistory - Character history for adaptive weighting\n * @param activeChars - Active character set (letters only used if they're active)\n * @param adaptiveGain - How much to weight toward weak characters (0-100)\n */\nexport function generateCallsign(\n  format: CallsignFormat,\n  callsignHistory: CallsignHistoryState,\n  activeChars: string[],\n  adaptiveGain: number\n): string {\n  // Filter to only use active letters/digits\n  const activeLetters = ALL_LETTERS.filter(l => activeChars.includes(l));\n  const activeDigits = DIGITS.filter(d => activeChars.includes(d));\n\n  // Must have at least some letters and digits\n  const lettersToUse = activeLetters.length > 0 ? activeLetters : ALL_LETTERS;\n  const digitsToUse = activeDigits.length > 0 ? activeDigits : DIGITS;\n\n  // First letter must be valid US prefix\n  const validFirstLetters = US_PREFIX_FIRST.filter(l => lettersToUse.includes(l));\n  const firstLetterCandidates = validFirstLetters.length > 0 ? validFirstLetters : US_PREFIX_FIRST;\n\n  let callsign = '';\n\n  // Generate prefix\n  callsign += selectWeightedChar(firstLetterCandidates, callsignHistory, adaptiveGain);\n\n  if (format.prefixLength === 2) {\n    // Second prefix letter can be any letter\n    callsign += selectWeightedChar(lettersToUse, callsignHistory, adaptiveGain);\n  }\n\n  // Generate digit (always exactly one)\n  callsign += selectWeightedChar(digitsToUse, callsignHistory, adaptiveGain);\n\n  // Generate suffix\n  for (let i = 0; i < format.suffixLength; i++) {\n    callsign += selectWeightedChar(lettersToUse, callsignHistory, adaptiveGain);\n  }\n\n  return callsign;\n}\n\n/**\n * Select a random format from enabled formats\n */\nexport function selectRandomFormat(enabledFormatIds: string[]): CallsignFormat {\n  const formats = getFormatsByIds(enabledFormatIds);\n\n  if (formats.length === 0) {\n    // Default to 2x3 if nothing enabled\n    return CALLSIGN_FORMATS.find(f => f.id === '2x3')!;\n  }\n\n  return formats[Math.floor(Math.random() * formats.length)];\n}\n\n/**\n * Generate a callsign using a random format from enabled formats\n */\nexport function generateRandomCallsign(\n  enabledFormatIds: string[],\n  callsignHistory: CallsignHistoryState,\n  activeChars: string[],\n  adaptiveGain: number,\n  previousCallsign: string | null = null\n): string {\n  const format = selectRandomFormat(enabledFormatIds);\n  let callsign = generateCallsign(format, callsignHistory, activeChars, adaptiveGain);\n\n  // Avoid immediate repeats (try up to 3 times)\n  let attempts = 0;\n  while (callsign === previousCallsign && attempts < 3) {\n    callsign = generateCallsign(format, callsignHistory, activeChars, adaptiveGain);\n    attempts++;\n  }\n\n  return callsign;\n}\n\n/**\n * Get the total length of a callsign for a given format\n */\nexport function getCallsignLength(format: CallsignFormat): number {\n  return format.prefixLength + 1 + format.suffixLength; // prefix + digit + suffix\n}\n","/**\n * Callsign Validator\n *\n * Parses spoken input and validates against expected callsign.\n * Uses flexible matching: any word starting with the correct letter is accepted.\n *\n * Examples:\n * - \"Kilo Echo Nine Bravo Oscar Sierra\" -> \"KE9BOS\" (NATO)\n * - \"Kevin Edward Nine Boston Oscar Sam\" -> \"KE9BOS\" (flexible)\n * - \"Kangaroo Elephant 9 Banana Orange Snake\" -> \"KE9BOS\" (also valid)\n */\n\n// Number word mappings (spoken word -> digit)\nconst NUMBER_WORDS: Record<string, string> = {\n  // Standard\n  'zero': '0',\n  'one': '1',\n  'two': '2',\n  'three': '3',\n  'four': '4',\n  'five': '5',\n  'six': '6',\n  'seven': '7',\n  'eight': '8',\n  'nine': '9',\n\n  // Ham radio / NATO variants\n  'niner': '9',\n  'tree': '3',\n  'fower': '4',\n  'fife': '5',\n\n  // Common misrecognitions\n  'oh': '0',\n  'o': '0',\n  'won': '1',\n  'wun': '1',\n  'to': '2',\n  'too': '2',\n  'free': '3',\n  'for': '4',\n  'ate': '8',\n  'ait': '8',\n};\n\nexport interface CallsignValidationResult {\n  isCorrect: boolean;\n  expected: string;\n  parsed: string;\n  errors: CallsignError[];\n}\n\nexport interface CallsignError {\n  position: number;\n  expected: string;\n  got: string;\n}\n\n/**\n * Parse a single spoken word to a callsign character\n *\n * @param word - The spoken word\n * @returns The character (letter or digit), or '?' if unrecognized\n */\nfunction parseWordToChar(word: string): string {\n  const normalized = word.toLowerCase().trim();\n\n  // Empty or whitespace\n  if (!normalized) {\n    return '?';\n  }\n\n  // Check if it's a number word\n  if (NUMBER_WORDS[normalized]) {\n    return NUMBER_WORDS[normalized];\n  }\n\n  // Check if it's a single digit\n  if (/^[0-9]$/.test(normalized)) {\n    return normalized;\n  }\n\n  // Check if it's an ordinal number (1st, 2nd, 3rd, 4th, 5th, 6th, 7th, 8th, 9th, 0th)\n  // Speech recognition often converts \"nine\" to \"9th\" etc.\n  const ordinalMatch = normalized.match(/^([0-9])(st|nd|rd|th)$/i);\n  if (ordinalMatch) {\n    return ordinalMatch[1];\n  }\n\n  // Check if it's a single letter\n  if (/^[a-z]$/i.test(normalized)) {\n    return normalized.toUpperCase();\n  }\n\n  // For any other word, take the first letter (flexible matching)\n  const firstChar = normalized.charAt(0);\n  if (/[a-z]/i.test(firstChar)) {\n    return firstChar.toUpperCase();\n  }\n\n  // Unrecognized\n  return '?';\n}\n\n/**\n * Parse spoken words into a callsign string\n *\n * @param transcript - The full spoken transcript (e.g., \"Kilo Echo Nine Bravo Oscar Sierra\")\n * @returns The parsed callsign (e.g., \"KE9BOS\")\n */\nexport function parseWordsToCallsign(transcript: string): string {\n  // Split into words, filtering out empty strings\n  const words = transcript\n    .trim()\n    .split(/\\s+/)\n    .filter(w => w.length > 0);\n\n  // Parse each word to a character\n  return words.map(parseWordToChar).join('');\n}\n\n/**\n * Validate a spoken transcript against an expected callsign\n *\n * @param expected - The expected callsign (e.g., \"KE9BOS\")\n * @param transcript - The spoken transcript (e.g., \"Kilo Echo Nine Bravo Oscar Sierra\")\n * @returns Validation result with detailed error information\n */\nexport function validateCallsign(\n  expected: string,\n  transcript: string\n): CallsignValidationResult {\n  const parsed = parseWordsToCallsign(transcript);\n  const expectedUpper = expected.toUpperCase();\n\n  const errors: CallsignError[] = [];\n\n  // Compare character by character\n  const maxLen = Math.max(expectedUpper.length, parsed.length);\n\n  for (let i = 0; i < maxLen; i++) {\n    const expectedChar = expectedUpper[i] || '';\n    const parsedChar = parsed[i] || '';\n\n    if (expectedChar !== parsedChar) {\n      errors.push({\n        position: i,\n        expected: expectedChar || '(missing)',\n        got: parsedChar || '(missing)',\n      });\n    }\n  }\n\n  return {\n    isCorrect: errors.length === 0 && parsed.length === expectedUpper.length,\n    expected: expectedUpper,\n    parsed,\n    errors,\n  };\n}\n\n/**\n * Format a callsign for display with error highlighting\n * Returns HTML with correct characters in green and errors in red\n *\n * @param result - The validation result\n * @returns HTML string for display\n */\nexport function formatCallsignFeedback(result: CallsignValidationResult): string {\n  if (result.isCorrect) {\n    return `<span class=\"correct\">${result.expected}</span>`;\n  }\n\n  const errorPositions = new Set(result.errors.map(e => e.position));\n  let html = '';\n\n  for (let i = 0; i < result.expected.length; i++) {\n    const char = result.expected[i];\n    if (errorPositions.has(i)) {\n      html += `<span class=\"incorrect\">${char}</span>`;\n    } else {\n      html += `<span class=\"correct\">${char}</span>`;\n    }\n  }\n\n  return html;\n}\n\n/**\n * Get a human-readable error description\n *\n * @param result - The validation result\n * @returns Description of what went wrong\n */\nexport function getErrorDescription(result: CallsignValidationResult): string {\n  if (result.isCorrect) {\n    return 'Correct!';\n  }\n\n  if (result.parsed.length === 0) {\n    return 'No response detected';\n  }\n\n  if (result.parsed.length !== result.expected.length) {\n    return `Expected ${result.expected.length} characters, got ${result.parsed.length}`;\n  }\n\n  if (result.errors.length === 1) {\n    const err = result.errors[0];\n    return `Position ${err.position + 1}: expected \"${err.expected}\", heard \"${err.got}\"`;\n  }\n\n  return `${result.errors.length} errors: ${result.errors.map(e => `\"${e.got}\" should be \"${e.expected}\"`).join(', ')}`;\n}\n","import { store } from '../state/store';\nimport { playMorseCharacter, playMorseWord, resumeAudioContext, stopAllAudio, playCorrectTone, playIncorrectTone } from '../core/morse-audio';\nimport { SpeechRecognizer, isSpeechRecognitionSupported, isIOS, isAndroid } from '../core/speech-recognition';\nimport { selectNextCharacter } from '../core/adaptive-selector';\nimport { selectNextWord, isWordModeAvailable } from '../core/word-selector';\nimport { generateRandomCallsign } from '../core/callsign-generator';\nimport { validateCallsign, getErrorDescription } from '../core/callsign-validator';\nimport { calculateWMA, calculatePenaltyTime } from '../core/weighted-average';\nimport { getCharDisplayName } from '../data/morse-codes';\nimport type { WordLength } from '../data/word-lists';\n\n\nconst BREAK_REMINDER_INTERVAL = 10 * 60 * 1000; // 10 minutes\nconst NEXT_CHAR_DELAY = 800; // Delay before next character (ms) - used for correct answers\nconst WRONG_ANSWER_DELAY = 6000; // Delay after wrong answer (ms) - gives time to hit \"Accept My Answer\"\nconst CALLSIGN_WRONG_DELAY = 4000; // Delay after wrong callsign (ms) - gives time to review the answer\n// Web Speech API has significant latency: time from speaking to when onresult fires\n// This includes audio capture, transmission to Google servers, processing, and return\n// Typical values: 500-1500ms depending on connection and phrase length\nconst SPEECH_API_LATENCY = 1200; // Increased latency compensation (ms)\n\n// Audio Level Monitor - shows real-time mic input during practice\nclass AudioLevelMonitor {\n  private audioContext: AudioContext | null = null;\n  private analyser: AnalyserNode | null = null;\n  private mediaStream: MediaStream | null = null;\n  private animationId: number | null = null;\n  private levelBar: HTMLElement | null = null;\n  private container: HTMLElement | null = null;\n  private isRunning: boolean = false;\n\n  constructor() {\n    this.container = document.getElementById('practice-level-container');\n    this.levelBar = document.getElementById('practice-level');\n  }\n\n  async start(): Promise<boolean> {\n    if (this.isRunning) return true;\n\n    try {\n      this.mediaStream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n        }\n      });\n\n      this.audioContext = new AudioContext();\n      this.analyser = this.audioContext.createAnalyser();\n      this.analyser.fftSize = 256;\n\n      const source = this.audioContext.createMediaStreamSource(this.mediaStream);\n      source.connect(this.analyser);\n\n      this.isRunning = true;\n      this.show();\n      this.updateLevel();\n      return true;\n    } catch (err) {\n      console.error('Failed to start audio level monitor:', err);\n      return false;\n    }\n  }\n\n  stop(): void {\n    this.isRunning = false;\n\n    if (this.animationId) {\n      cancelAnimationFrame(this.animationId);\n      this.animationId = null;\n    }\n\n    if (this.mediaStream) {\n      this.mediaStream.getTracks().forEach(track => track.stop());\n      this.mediaStream = null;\n    }\n\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n\n    this.analyser = null;\n    this.hide();\n  }\n\n  show(): void {\n    this.container?.classList.remove('hidden');\n  }\n\n  hide(): void {\n    this.container?.classList.add('hidden');\n    if (this.levelBar) {\n      this.levelBar.style.width = '0%';\n    }\n  }\n\n  private updateLevel(): void {\n    if (!this.analyser || !this.isRunning) return;\n\n    const dataArray = new Uint8Array(this.analyser.frequencyBinCount);\n    this.analyser.getByteFrequencyData(dataArray);\n\n    // Calculate average volume\n    const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;\n    const level = Math.min(100, (average / 128) * 100);\n\n    if (this.levelBar) {\n      this.levelBar.style.width = `${level}%`;\n\n      // Update color class based on level\n      this.levelBar.classList.remove('low', 'medium', 'high');\n      if (level < 20) {\n        this.levelBar.classList.add('low');\n      } else if (level < 50) {\n        this.levelBar.classList.add('medium');\n      } else {\n        this.levelBar.classList.add('high');\n      }\n    }\n\n    this.animationId = requestAnimationFrame(() => this.updateLevel());\n  }\n}\n\nexport class PracticeSession {\n  private recognizer: SpeechRecognizer | null = null;\n  private previousChar: string | null = null;\n  private previousWord: string | null = null;\n  private previousCallsign: string | null = null;\n  private currentWord: string | null = null; // Track current word in word mode\n  private currentCallsign: string | null = null; // Track current callsign in callsign mode\n  private audioPlayedAt: number = 0;\n  private breakCheckInterval: number | null = null;\n  private nextCharTimeout: number | null = null;\n  private isPlayingChar: boolean = false;\n  // Use continuous mode on iOS to avoid jingle on each start/stop\n  private useContinuousMode: boolean = false;\n  // Track if we just restarted speech recognition (needs longer delay)\n  private justRestartedRecognition: boolean = false;\n  // Screen wake lock to prevent device sleep during practice\n  private wakeLock: WakeLockSentinel | null = null;\n\n  // Track last wrong answer for \"Accept My Answer\" feature\n  private lastWrongAnswer: {\n    expected: string;\n    heard: string;\n    responseTime: number;\n    isWordMode: boolean;\n  } | null = null;\n\n  // Track last attempt for recovery/undo feature\n  private lastAttempt: {\n    type: 'character' | 'word' | 'callsign';\n    value: string;\n    chars: string[];\n    wasCorrect: boolean;\n    previousWMAs: Record<string, { wma: number; mostRecent: number }>;\n  } | null = null;\n\n  // Audio level monitor for visual feedback\n  private audioLevelMonitor: AudioLevelMonitor;\n\n  // DOM elements\n  private startBtn: HTMLButtonElement;\n  private currentCharEl: HTMLElement;\n  private feedbackTextEl: HTMLElement;\n  private listeningIndicator: HTMLElement;\n  private breakModal: HTMLElement;\n  private debugHeardEl: HTMLElement;\n  private acceptAnswerBtn: HTMLButtonElement;\n  private recoveryBtn: HTMLButtonElement;\n\n  constructor() {\n    this.startBtn = document.getElementById('start-btn') as HTMLButtonElement;\n    this.currentCharEl = document.getElementById('current-char') as HTMLElement;\n    this.feedbackTextEl = document.getElementById('feedback-text') as HTMLElement;\n    this.listeningIndicator = document.getElementById('listening-indicator') as HTMLElement;\n    this.breakModal = document.getElementById('break-modal') as HTMLElement;\n    this.debugHeardEl = document.getElementById('debug-heard') as HTMLElement;\n    this.acceptAnswerBtn = document.getElementById('accept-answer-btn') as HTMLButtonElement;\n    this.recoveryBtn = document.getElementById('recovery-btn') as HTMLButtonElement;\n\n    // Initialize audio level monitor\n    this.audioLevelMonitor = new AudioLevelMonitor();\n\n    // Listen for visibility changes to re-acquire wake lock when returning to app\n    document.addEventListener('visibilitychange', this.handleVisibilityChange);\n\n    this.setupEventListeners();\n    this.initializeSpeechRecognition();\n  }\n\n  private setupEventListeners(): void {\n    this.startBtn.addEventListener('click', () => this.toggleSession());\n\n    // Accept My Answer button\n    this.acceptAnswerBtn?.addEventListener('click', () => this.handleAcceptAnswer());\n\n    // Recovery/Restart button\n    this.recoveryBtn?.addEventListener('click', () => this.handleRecovery());\n\n    // Break modal dismiss\n    const dismissBtn = document.getElementById('dismiss-break');\n    dismissBtn?.addEventListener('click', () => {\n      this.breakModal.classList.add('hidden');\n      store.updateSession({ lastBreakReminder: Date.now() });\n    });\n\n    // Subscribe to session changes\n    store.subscribe('session', (session) => {\n      if (session.isRunning) {\n        this.startBtn.textContent = 'Pause';\n        this.startBtn.classList.add('running');\n        // Show recovery button when session is running\n        this.recoveryBtn?.classList.remove('hidden');\n      } else {\n        this.startBtn.textContent = 'Start';\n        this.startBtn.classList.remove('running');\n        this.listeningIndicator.classList.add('hidden');\n        // Hide accept button when session stops\n        this.hideAcceptButton();\n        // Hide recovery button when session stops\n        this.recoveryBtn?.classList.add('hidden');\n      }\n    });\n  }\n\n  private showAcceptButton(): void {\n    this.acceptAnswerBtn?.classList.remove('hidden');\n  }\n\n  private hideAcceptButton(): void {\n    this.acceptAnswerBtn?.classList.add('hidden');\n    this.lastWrongAnswer = null;\n  }\n\n  // Wake lock management - keeps screen awake during practice\n  private async acquireWakeLock(): Promise<void> {\n    if ('wakeLock' in navigator) {\n      try {\n        this.wakeLock = await navigator.wakeLock.request('screen');\n      } catch (err) {\n        // Wake lock request failed (e.g., low battery mode)\n      }\n    }\n  }\n\n  private releaseWakeLock(): void {\n    if (this.wakeLock) {\n      this.wakeLock.release();\n      this.wakeLock = null;\n    }\n  }\n\n  private handleVisibilityChange = async (): Promise<void> => {\n    // Re-acquire wake lock when returning to the app (wake locks are released when backgrounded)\n    if (document.visibilityState === 'visible' && store.getSession().isRunning) {\n      await this.acquireWakeLock();\n    }\n  };\n\n  // Handle recovery button - undo last attempt and restart session\n  // Uses the exact same stop/start flow as the pause/start buttons\n  private handleRecovery(): void {\n    const session = store.getSession();\n    if (!session.isRunning) return;\n\n    console.log('Recovery triggered - will stop then restart session');\n\n    // Revert the last attempt if there was one\n    if (this.lastAttempt) {\n      const { type, chars, wasCorrect, previousWMAs } = this.lastAttempt;\n\n      if (type === 'character' && chars.length === 1) {\n        const prev = previousWMAs[chars[0]];\n        if (prev) {\n          store.revertCharacterAttempt(chars[0], wasCorrect, prev.wma, prev.mostRecent);\n        }\n      } else if (type === 'word') {\n        store.revertWordCharacterAttempts(chars, wasCorrect, previousWMAs);\n      } else if (type === 'callsign') {\n        store.revertCallsignCharacterAttempts(chars, wasCorrect, previousWMAs);\n      }\n\n      // Decrement session total\n      const currentTotal = store.getSession().totalCharsThisSession;\n      if (currentTotal > 0) {\n        store.updateSession({ totalCharsThisSession: currentTotal - 1 });\n      }\n\n      console.log('Last attempt reverted');\n      this.lastAttempt = null;\n    }\n\n    // Do exactly what the Pause button does\n    this.stop();\n    this.feedbackTextEl.textContent = 'Restarting in 3 seconds...';\n\n    // After 3 seconds, do exactly what the Start button does\n    setTimeout(async () => {\n      // Make sure we weren't manually stopped\n      if (store.getSession().isRunning) {\n        // Session is still marked as running from somewhere else, stop it first\n        return;\n      }\n\n      this.feedbackTextEl.textContent = 'Restarting...';\n      await this.start();\n    }, 3000);\n  }\n\n  // Get words that sound similar (for alias sharing)\n  // Words that differ only in vowels often sound alike when spoken quickly\n  private getSimilarSoundingWords(word: string): string[] {\n    const upper = word.toUpperCase();\n\n    // Define groups of similar-sounding words\n    const similarGroups: string[][] = [\n      ['TEN', 'TAN', 'TIN', 'TON', 'TUN'],\n      ['PEN', 'PAN', 'PIN', 'PUN'],\n      ['BET', 'BAT', 'BIT', 'BUT', 'BOT'],\n      ['SET', 'SAT', 'SIT'],\n      ['MEN', 'MAN', 'MIN'],\n      ['NET', 'NAT', 'NIT', 'NUT', 'NOT'],\n      ['PET', 'PAT', 'PIT', 'PUT', 'POT'],\n      ['BED', 'BAD', 'BID', 'BUD'],\n      ['RED', 'RAD', 'RID', 'ROD'],\n      ['LED', 'LAD', 'LID'],\n      ['WET', 'WAT', 'WIT'],\n      ['HEN', 'HAN'],\n      ['DEN', 'DAN', 'DIN', 'DON', 'DUN'],\n      ['RUN', 'RAN'],\n      ['SUN', 'SON'],\n      ['WON', 'ONE', 'WIN'],\n      ['FUN', 'FAN', 'FIN'],\n      ['GUN', 'GAN'],\n      ['CAN', 'CON', 'KIN'],\n      ['CAP', 'COP', 'CUP'],\n      ['MAP', 'MOP', 'MIP'],\n      ['TAP', 'TIP', 'TOP'],\n      ['RAP', 'RIP', 'REP'],\n      ['LAP', 'LIP', 'LOP'],\n      ['SAP', 'SIP', 'SUP', 'SOP'],\n      ['HAP', 'HIP', 'HOP'],\n      ['DAM', 'DIM', 'DUM'],\n      ['HAM', 'HIM', 'HUM'],\n      ['JAM', 'JIM'],\n      ['RAM', 'RIM', 'RUM'],\n      ['CAT', 'COT', 'CUT'],\n      ['HAT', 'HIT', 'HOT', 'HUT'],\n      ['RAT', 'RUT', 'ROT'],\n      ['MAT', 'MIT', 'MUT'],\n      ['FOR', 'FUR', 'FAR'],\n      ['BAR', 'BUR'],\n      ['CAR', 'CUR'],\n      ['TAR', 'TOR'],\n    ];\n\n    // Find the group containing this word\n    for (const group of similarGroups) {\n      if (group.includes(upper)) {\n        return group;\n      }\n    }\n\n    // No similar words found, return just the original\n    return [upper];\n  }\n\n  private handleAcceptAnswer(): void {\n    if (!this.lastWrongAnswer) return;\n\n    const { expected, heard, responseTime, isWordMode } = this.lastWrongAnswer;\n\n    // For word mode, add the alias to all similar-sounding words\n    if (isWordMode) {\n      const similarWords = this.getSimilarSoundingWords(expected);\n      for (const word of similarWords) {\n        store.addPronunciationAlias(word, heard, true);\n      }\n      // Show which words were updated\n      const savedCount = similarWords.length;\n      this.feedbackTextEl.textContent = savedCount > 1\n        ? `Saved! \"${heard}\" accepted for ${savedCount} similar words`\n        : `Saved! \"${heard}\" now accepted for \"${expected}\"`;\n    } else {\n      // Character mode - just save for the single character\n      store.addPronunciationAlias(expected, heard, false);\n      this.feedbackTextEl.textContent = `Saved! \"${heard}\" now accepted for \"${expected}\"`;\n    }\n\n    // Update display to show it was saved\n    this.acceptAnswerBtn.classList.add('saving');\n    this.currentCharEl.className = 'current-char correct';\n\n    // Play success tone\n    const settings = store.getSettings();\n    playCorrectTone(settings.volume * 0.6);\n\n    // Re-score as correct - update the appropriate history\n    if (isWordMode) {\n      // Update word character history for each character in the word\n      // Split the response time by number of characters\n      const perCharTime = responseTime / expected.length;\n      for (const char of expected.toUpperCase()) {\n        const charHistory = store.getWordCharacterHistory(char);\n        const newWMA = calculateWMA(charHistory.wma, perCharTime, true);\n\n        store.updateWordCharacterHistory(char, {\n          wma: newWMA,\n          mostRecent: perCharTime,\n          totalAttempts: charHistory.totalAttempts, // Don't increment again\n          correctAttempts: charHistory.correctAttempts + 1, // But do credit the correct\n          lastPracticed: Date.now(),\n        });\n      }\n    } else {\n      // Update character history\n      const charHistory = store.getCharacterHistory(expected);\n      const newWMA = calculateWMA(charHistory.wma, responseTime, true);\n\n      store.updateCharacterHistory(expected, {\n        wma: newWMA,\n        mostRecent: responseTime,\n        totalAttempts: charHistory.totalAttempts, // Don't increment again\n        correctAttempts: charHistory.correctAttempts + 1, // But do credit the correct\n        lastPracticed: Date.now(),\n      });\n    }\n\n    // Clear the last wrong answer\n    this.lastWrongAnswer = null;\n\n    // Hide the button after a short delay\n    setTimeout(() => {\n      this.acceptAnswerBtn.classList.remove('saving');\n      this.hideAcceptButton();\n    }, 500);\n  }\n\n  // Helper: Pause recognition during audio playback\n  private pauseRecognition(): void {\n    if (!this.recognizer) return;\n    if (this.useContinuousMode) {\n      this.recognizer.ignoreResults();\n    } else {\n      this.recognizer.stop();\n    }\n  }\n\n  private initializeSpeechRecognition(): void {\n    // Note: We tried Whisper for Android to avoid the Chrome speech recognition chime,\n    // but it's too slow (3-8 seconds) and hallucinates words from background noise.\n    // Sticking with Web Speech API - the chime is annoying but at least it works.\n\n    if (!isSpeechRecognitionSupported()) {\n      this.feedbackTextEl.textContent = 'Speech recognition not supported';\n      this.startBtn.disabled = true;\n      return;\n    }\n\n    const recognizer = new SpeechRecognizer();\n\n    // On iOS Safari and Android Chrome, use continuous mode to avoid the jingle on each start/stop\n    // On Android, this also prevents recognition from timing out during morse playback\n    if (isIOS() || isAndroid()) {\n      this.useContinuousMode = true;\n      recognizer.setContinuousMode(true);\n      console.log('Mobile detected: using continuous speech recognition mode');\n    }\n\n    this.recognizer = recognizer;\n    this.setupRecognizerCallbacks();\n  }\n\n  private setupRecognizerCallbacks(): void {\n    if (!this.recognizer) return;\n\n    this.recognizer.onResult((result) => {\n      this.handleRecognitionResult(result.transcript, result.rawTranscript, result.timestamp);\n    });\n\n    // Show ALL raw transcripts in debug (even unrecognized ones)\n    this.recognizer.onRaw((rawTranscript, normalized) => {\n      if (this.debugHeardEl) {\n        if (normalized) {\n          this.debugHeardEl.textContent = `Heard: \"${rawTranscript}\" → ${normalized}`;\n          this.debugHeardEl.style.color = '#00d26a'; // green\n        } else {\n          this.debugHeardEl.textContent = `Heard: \"${rawTranscript}\" → (not recognized)`;\n          this.debugHeardEl.style.color = '#ff4757'; // red\n        }\n      }\n    });\n\n    this.recognizer.onError((error) => {\n      // Handle critical errors only\n      if (error === 'not-allowed') {\n        this.feedbackTextEl.textContent = 'Microphone access denied. Please allow microphone access.';\n        this.stop();\n      } else if (error === 'network') {\n        this.feedbackTextEl.textContent = 'Network error. Check your connection.';\n      }\n    });\n\n    // Handle unexpected recognition end (e.g., no-speech timeout)\n    // Only SpeechRecognizer has onEnd, not WhisperRecognizer\n    // On Android, do NOT auto-restart - it causes annoying chime loops\n    if ('onEnd' in this.recognizer && !isAndroid()) {\n      (this.recognizer as SpeechRecognizer).onEnd(() => {\n        // If session is still running and we're supposed to be listening, restart\n        const session = store.getSession();\n        if (session.isRunning && !this.isPlayingChar) {\n          console.log('Recognition ended unexpectedly, restarting...');\n          // Small delay before restarting to avoid rapid restart loops\n          setTimeout(() => {\n            if (store.getSession().isRunning && this.recognizer && !this.isPlayingChar) {\n              // Re-enable callsign mode if we're in callsign mode\n              const wordModeSettings = store.getWordModeSettings();\n              if (wordModeSettings.practiceMode === 'callsign' && this.currentCallsign) {\n                if (this.recognizer instanceof SpeechRecognizer) {\n                  this.recognizer.setCallsignMode(true, this.currentCallsign.length);\n                }\n              }\n              this.recognizer.start();\n            }\n          }, 100);\n        }\n      });\n    }\n  }\n\n  private async toggleSession(): Promise<void> {\n    const session = store.getSession();\n\n    if (session.isRunning) {\n      this.stop();\n    } else {\n      await this.start();\n    }\n  }\n\n  async start(): Promise<void> {\n    // Ensure audio context is resumed (required after user gesture)\n    await resumeAudioContext();\n\n    // Keep screen awake during practice\n    await this.acquireWakeLock();\n\n    // Start audio level monitor for visual feedback\n    // EXCEPT on Android - getUserMedia blocks Web Speech API from accessing mic\n    if (!isAndroid()) {\n      await this.audioLevelMonitor.start();\n    }\n\n    // Clear any previous attempt tracking\n    this.lastAttempt = null;\n\n    store.startSession();\n\n    // Start break check interval\n    this.breakCheckInterval = window.setInterval(() => {\n      this.checkBreakReminder();\n    }, 60000);\n\n    // In continuous mode (iOS/Android), start recognition once at session start\n    // It will keep running and we'll use acceptResults/ignoreResults to control\n    if (this.useContinuousMode && this.recognizer && this.recognizer instanceof SpeechRecognizer) {\n      console.log('Starting continuous recognition for session');\n      this.recognizer.start();\n      this.recognizer.ignoreResults(); // Start ignoring until we're ready\n\n      // Wait for the speech recognition chime to finish\n      // Android Chrome: chime plays, recognition restarts a few times, need longer delay\n      // iOS Safari: simpler jingle, ~3 seconds\n      const chimeDelay = isAndroid() ? 3500 : 3000;\n      this.feedbackTextEl.textContent = 'Starting microphone...';\n      await new Promise(resolve => setTimeout(resolve, chimeDelay));\n\n      // Check if session was stopped during the delay\n      if (!store.getSession().isRunning) return;\n    }\n\n    // Play first character\n    this.playNextCharacter();\n  }\n\n  stop(): void {\n    store.stopSession();\n\n    // Release screen wake lock\n    this.releaseWakeLock();\n\n    // Stop any playing audio\n    stopAllAudio();\n    this.isPlayingChar = false;\n\n    // Cancel any pending next character\n    if (this.nextCharTimeout) {\n      clearTimeout(this.nextCharTimeout);\n      this.nextCharTimeout = null;\n    }\n\n    if (this.recognizer) {\n      this.recognizer.stop();\n    }\n\n    if (this.breakCheckInterval) {\n      clearInterval(this.breakCheckInterval);\n      this.breakCheckInterval = null;\n    }\n\n    // Stop audio level monitor\n    this.audioLevelMonitor.stop();\n\n    // Clear attempt tracking\n    this.lastAttempt = null;\n\n    this.listeningIndicator.classList.add('hidden');\n    this.currentCharEl.textContent = '—';\n    this.currentCharEl.className = 'current-char';\n    this.feedbackTextEl.textContent = 'Press Start to begin';\n  }\n\n  private async playNextCharacter(): Promise<void> {\n    const session = store.getSession();\n    if (!session.isRunning) return;\n\n    // Prevent overlapping character plays\n    if (this.isPlayingChar) return;\n    this.isPlayingChar = true;\n\n    const activeChars = store.getActiveCharacters();\n    if (activeChars.length === 0) {\n      this.feedbackTextEl.textContent = 'No characters selected';\n      this.isPlayingChar = false;\n      this.stop();\n      return;\n    }\n\n    const settings = store.getSettings();\n    const wordModeSettings = store.getWordModeSettings();\n\n    // Check if we're in word mode\n    if (wordModeSettings.practiceMode === 'word') {\n      await this.playNextWord();\n      return;\n    }\n\n    // Check if we're in callsign mode\n    if (wordModeSettings.practiceMode === 'callsign') {\n      await this.playNextCallsign();\n      return;\n    }\n\n    // Character mode logic\n    const history = store.getHistory();\n\n    // Select next character\n    const char = selectNextCharacter(\n      activeChars,\n      history,\n      settings.adaptiveGain,\n      this.previousChar\n    );\n\n    store.updateSession({ currentChar: char });\n    this.previousChar = char;\n    this.currentWord = null; // Clear any word state\n\n    // Reset display\n    this.currentCharEl.textContent = '—';\n    this.currentCharEl.className = 'current-char';\n    this.feedbackTextEl.textContent = 'Listen...';\n    this.listeningIndicator.classList.add('hidden');\n\n    // Set the expected character for flexible mode validation\n    if (this.recognizer) {\n      this.recognizer.setExpectedChar(char);\n    }\n\n    // On Android (non-continuous mode), we need to start recognition BEFORE playing morse\n    // so the chime has time to finish before the morse audio plays\n    if (isAndroid() && !this.useContinuousMode && this.recognizer) {\n      console.log('Android: starting recognition before morse (chime will play)');\n      this.recognizer.start();\n      // Wait for the Android Chrome chime to finish (~2 seconds)\n      this.feedbackTextEl.textContent = 'Starting...';\n      await new Promise(resolve => setTimeout(resolve, 2000));\n\n      // Check if session was stopped during the delay\n      if (!store.getSession().isRunning) {\n        this.isPlayingChar = false;\n        return;\n      }\n      this.feedbackTextEl.textContent = 'Listen...';\n    } else {\n      // iOS continuous mode or desktop: pause recognition during audio\n      this.pauseRecognition();\n    }\n\n    // Play morse audio\n    const completed = await playMorseCharacter(\n      char,\n      settings.characterSpeed,\n      settings.toneFrequency,\n      settings.volume\n    );\n\n    // Check if session was stopped during playback\n    if (!store.getSession().isRunning || !completed) {\n      this.isPlayingChar = false;\n      return;\n    }\n\n    // Record when audio finished\n    this.audioPlayedAt = performance.now();\n    this.isPlayingChar = false;\n\n    // Start listening\n    this.feedbackTextEl.textContent = 'Speak the character';\n    this.listeningIndicator.classList.remove('hidden');\n\n    // Handle post-audio recognition setup\n    if (this.recognizer) {\n      if (this.useContinuousMode) {\n        // After a restart, WebKit needs extra time before it's ready to process speech\n        // Normal operation just needs a small delay to flush buffered results\n        const delay = this.justRestartedRecognition ? 2000 : 100;\n        if (this.justRestartedRecognition) {\n          console.log('Post-restart: waiting extra time for WebKit to be ready');\n          this.justRestartedRecognition = false;\n        }\n        await new Promise(resolve => setTimeout(resolve, delay));\n        // Update audioPlayedAt after the delay for accurate timing\n        this.audioPlayedAt = performance.now();\n        this.recognizer.acceptResults();\n      } else if (!isAndroid()) {\n        // Desktop (non-continuous): start recognition now\n        this.recognizer.start();\n      }\n      // Android: recognition was already started before morse audio\n    }\n  }\n\n  private async playNextWord(): Promise<void> {\n    const session = store.getSession();\n    if (!session.isRunning) return;\n\n    const activeChars = store.getActiveCharacters();\n    const settings = store.getSettings();\n    const wordModeSettings = store.getWordModeSettings();\n    const wordHistory = store.getWordHistory();\n    const wordLength = wordModeSettings.wordLength as WordLength;\n\n    // Check if word mode is available with current character set\n    if (!isWordModeAvailable(wordLength, activeChars)) {\n      this.feedbackTextEl.textContent = 'No words available with current character set';\n      this.isPlayingChar = false;\n      this.stop();\n      return;\n    }\n\n    // Select next word\n    const word = selectNextWord(\n      wordLength,\n      wordHistory,\n      activeChars,\n      settings.adaptiveGain,\n      this.previousWord\n    );\n\n    this.currentWord = word;\n    this.previousWord = word;\n    store.updateSession({ currentChar: word }); // Store word in currentChar for display\n\n    // Reset display\n    this.currentCharEl.textContent = '—';\n    this.currentCharEl.className = 'current-char';\n    this.feedbackTextEl.textContent = 'Listen...';\n    this.listeningIndicator.classList.add('hidden');\n\n    // Set expected to null for word mode - we'll handle validation differently\n    if (this.recognizer) {\n      this.recognizer.setExpectedChar(null);\n    }\n\n    // On Android (non-continuous mode), start recognition BEFORE playing morse\n    // so the chime has time to finish before the morse audio plays\n    if (isAndroid() && !this.useContinuousMode && this.recognizer) {\n      console.log('Android: starting recognition before morse word (chime will play)');\n      this.recognizer.start();\n      this.feedbackTextEl.textContent = 'Starting...';\n      await new Promise(resolve => setTimeout(resolve, 2000));\n\n      if (!store.getSession().isRunning) {\n        this.isPlayingChar = false;\n        return;\n      }\n      this.feedbackTextEl.textContent = 'Listen...';\n    } else if (this.recognizer) {\n      // iOS continuous mode or desktop: pause recognition during audio\n      if (this.useContinuousMode) {\n        this.recognizer.ignoreResults();\n      } else {\n        this.recognizer.stop();\n      }\n    }\n\n    // Play morse word audio\n    const completed = await playMorseWord(\n      word,\n      settings.characterSpeed,\n      settings.toneFrequency,\n      settings.volume\n    );\n\n    // Check if session was stopped during playback\n    if (!store.getSession().isRunning || !completed) {\n      this.isPlayingChar = false;\n      return;\n    }\n\n    // Record when audio finished\n    this.audioPlayedAt = performance.now();\n    this.isPlayingChar = false;\n\n    // Start listening\n    this.feedbackTextEl.textContent = 'Speak the word';\n    this.listeningIndicator.classList.remove('hidden');\n\n    // Handle post-audio recognition setup\n    if (this.recognizer) {\n      if (this.useContinuousMode) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n        this.audioPlayedAt = performance.now();\n        this.recognizer.acceptResults();\n      } else if (!isAndroid()) {\n        // Desktop (non-continuous): start recognition now\n        this.recognizer.start();\n      }\n      // Android: recognition was already started before morse audio\n    }\n  }\n\n  // Replay the current character (used in repeat-until-correct mode)\n  private async replayCurrentCharacter(): Promise<void> {\n    const session = store.getSession();\n    if (!session.isRunning || !session.currentChar) return;\n\n    // Prevent overlapping character plays\n    if (this.isPlayingChar) return;\n    this.isPlayingChar = true;\n\n    const settings = store.getSettings();\n\n    // Reset display for replay\n    this.currentCharEl.textContent = '—';\n    this.currentCharEl.className = 'current-char';\n    this.feedbackTextEl.textContent = 'Listen...';\n    this.listeningIndicator.classList.add('hidden');\n\n    // Set the expected character for flexible mode validation\n    if (this.recognizer) {\n      this.recognizer.setExpectedChar(session.currentChar);\n    }\n\n    // On Android (non-continuous mode), start recognition BEFORE playing morse\n    if (isAndroid() && !this.useContinuousMode && this.recognizer) {\n      console.log('Android: starting recognition before morse replay (chime will play)');\n      this.recognizer.start();\n      this.feedbackTextEl.textContent = 'Starting...';\n      await new Promise(resolve => setTimeout(resolve, 2000));\n\n      if (!store.getSession().isRunning) {\n        this.isPlayingChar = false;\n        return;\n      }\n      this.feedbackTextEl.textContent = 'Listen...';\n    } else if (this.recognizer) {\n      // iOS continuous mode or desktop: pause recognition during audio\n      if (this.useContinuousMode) {\n        this.recognizer.ignoreResults();\n      } else {\n        this.recognizer.stop();\n      }\n    }\n\n    // Play morse audio for the same character\n    const completed = await playMorseCharacter(\n      session.currentChar,\n      settings.characterSpeed,\n      settings.toneFrequency,\n      settings.volume\n    );\n\n    // Check if session was stopped during playback\n    if (!store.getSession().isRunning || !completed) {\n      this.isPlayingChar = false;\n      return;\n    }\n\n    // Record when audio finished\n    this.audioPlayedAt = performance.now();\n    this.isPlayingChar = false;\n\n    // Start listening\n    this.feedbackTextEl.textContent = 'Speak the character';\n    this.listeningIndicator.classList.remove('hidden');\n\n    // Handle post-audio recognition setup\n    if (this.recognizer) {\n      if (this.useContinuousMode) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n        this.audioPlayedAt = performance.now();\n        this.recognizer.acceptResults();\n      } else if (!isAndroid()) {\n        // Desktop (non-continuous): start recognition now\n        this.recognizer.start();\n      }\n      // Android: recognition was already started before morse audio\n    }\n  }\n\n  private handleRecognitionResult(recognized: string, rawTranscript: string, timestamp: number): void {\n    const session = store.getSession();\n    if (!session.isRunning || !session.currentChar) return;\n\n    const wordModeSettings = store.getWordModeSettings();\n\n    // Check if we're in word mode\n    if (wordModeSettings.practiceMode === 'word' && this.currentWord) {\n      this.handleWordRecognitionResult(rawTranscript, timestamp);\n      return;\n    }\n\n    // Check if we're in callsign mode\n    if (wordModeSettings.practiceMode === 'callsign' && this.currentCallsign) {\n      this.handleCallsignRecognitionResult(rawTranscript, timestamp);\n      return;\n    }\n\n    // Stop accepting results (in continuous mode, recognition keeps running)\n    if (this.recognizer) {\n      if (this.useContinuousMode && this.recognizer instanceof SpeechRecognizer) {\n        this.recognizer.ignoreResults();\n      } else {\n        this.recognizer.stop();\n      }\n    }\n    this.listeningIndicator.classList.add('hidden');\n    this.hideAcceptButton(); // Hide any previous accept button\n\n    // Calculate response time (compensate for Web Speech API latency)\n    const rawResponseTime = timestamp - this.audioPlayedAt;\n    const responseTime = Math.max(100, rawResponseTime - SPEECH_API_LATENCY);\n\n    // Check if correct - either direct match OR matches a pronunciation alias\n    const directMatch = recognized.toUpperCase() === session.currentChar.toUpperCase();\n    const aliasMatch = store.matchesAlias(session.currentChar, rawTranscript, false);\n    const isCorrect = directMatch || aliasMatch;\n\n    // Update display\n    const displayChar = getCharDisplayName(session.currentChar);\n    this.currentCharEl.textContent = displayChar;\n    this.currentCharEl.className = `current-char ${isCorrect ? 'correct' : 'incorrect'}`;\n\n    // Play feedback tone\n    const settings = store.getSettings();\n    if (isCorrect) {\n      playCorrectTone(settings.volume * 0.6);\n    } else {\n      playIncorrectTone(settings.volume * 0.6);\n    }\n\n    if (isCorrect) {\n      this.feedbackTextEl.textContent = `Correct! ${Math.round(responseTime)}ms`;\n      // Show raw timing in debug for calibration\n      if (this.debugHeardEl) {\n        const aliasNote = aliasMatch && !directMatch ? ' (alias)' : '';\n        this.debugHeardEl.textContent = `Heard: \"${rawTranscript}\"${aliasNote} | adjusted: ${Math.round(responseTime)}ms | raw: ${Math.round(rawResponseTime)}ms`;\n        this.debugHeardEl.style.color = '#00d26a';\n      }\n    } else {\n      // Check if this was an unrecognized word (special marker from speech recognition)\n      const isUnrecognized = recognized.startsWith('[unrecognized:');\n\n      if (settings.repeatUntilCorrect) {\n        // Don't reveal the answer in repeat mode - they need to figure it out\n        this.feedbackTextEl.textContent = 'Incorrect - try again';\n        this.currentCharEl.textContent = '—';\n        this.currentCharEl.className = 'current-char incorrect';\n      } else {\n        if (isUnrecognized) {\n          // Show the raw transcript they said\n          this.feedbackTextEl.textContent = `\"${rawTranscript}\" not recognized - was \"${displayChar}\"`;\n        } else {\n          // Normal behavior: show what they said and the correct answer\n          const recognizedDisplay = getCharDisplayName(recognized);\n          this.feedbackTextEl.textContent = `You said \"${recognizedDisplay}\" - was \"${displayChar}\"`;\n        }\n      }\n\n      // Accept My Answer feature is only for word mode - not character mode\n    }\n\n    // Store previous state for recovery\n    const charHistory = store.getCharacterHistory(session.currentChar);\n    this.lastAttempt = {\n      type: 'character',\n      value: session.currentChar,\n      chars: [session.currentChar],\n      wasCorrect: isCorrect,\n      previousWMAs: {\n        [session.currentChar]: { wma: charHistory.wma, mostRecent: charHistory.mostRecent }\n      }\n    };\n\n    // Update history\n    const newWMA = calculateWMA(charHistory.wma, responseTime, isCorrect);\n\n    store.updateCharacterHistory(session.currentChar, {\n      wma: newWMA,\n      mostRecent: isCorrect ? responseTime : calculatePenaltyTime(charHistory.wma),\n      totalAttempts: charHistory.totalAttempts + 1,\n      correctAttempts: charHistory.correctAttempts + (isCorrect ? 1 : 0),\n      lastPracticed: Date.now(),\n    });\n\n    // Update session stats\n    store.updateSession({\n      totalCharsThisSession: session.totalCharsThisSession + 1,\n    });\n\n    // Schedule next character (cancel any previous pending)\n    if (this.nextCharTimeout) {\n      clearTimeout(this.nextCharTimeout);\n    }\n\n    if (!isCorrect && settings.repeatUntilCorrect) {\n      // Repeat mode: short delay then replay (no Accept My Answer in character mode)\n      this.nextCharTimeout = window.setTimeout(() => {\n        this.nextCharTimeout = null;\n        if (store.getSession().isRunning) {\n          this.replayCurrentCharacter();\n        }\n      }, NEXT_CHAR_DELAY);\n    } else if (!isCorrect) {\n      // Wrong answer (not in repeat mode): short delay then next character\n      this.nextCharTimeout = window.setTimeout(() => {\n        this.nextCharTimeout = null;\n        if (store.getSession().isRunning) {\n          this.playNextCharacter();\n        }\n      }, NEXT_CHAR_DELAY);\n    } else {\n      // Correct answer: move to next quickly\n      this.nextCharTimeout = window.setTimeout(() => {\n        this.nextCharTimeout = null;\n        if (store.getSession().isRunning) {\n          this.playNextCharacter();\n        }\n      }, NEXT_CHAR_DELAY);\n    }\n  }\n\n  private handleWordRecognitionResult(rawTranscript: string, timestamp: number): void {\n    const session = store.getSession();\n    if (!session.isRunning || !this.currentWord) return;\n\n    // Stop accepting results\n    if (this.recognizer) {\n      if (this.useContinuousMode && this.recognizer instanceof SpeechRecognizer) {\n        this.recognizer.ignoreResults();\n      } else {\n        this.recognizer.stop();\n      }\n    }\n    this.listeningIndicator.classList.add('hidden');\n    this.hideAcceptButton(); // Hide any previous accept button\n\n    // Calculate response time\n    const rawResponseTime = timestamp - this.audioPlayedAt;\n    const responseTime = Math.max(100, rawResponseTime - SPEECH_API_LATENCY);\n\n    // Normalize the raw transcript for comparison\n    // First try letters only, but if that results in empty string, keep original for alias matching\n    const lettersOnly = rawTranscript.toUpperCase().trim().replace(/[^A-Z]/g, '');\n    const spokenWord = lettersOnly || rawTranscript.toUpperCase().trim();\n    const expectedWord = this.currentWord.toUpperCase();\n\n    // Map numbers to possible word equivalents\n    // This handles cases like \"ten\" being recognized as \"10\"\n    const soundToWords: Record<string, string[]> = {\n      '1': ['ONE', 'WON'],\n      '2': ['TWO', 'TOO'],\n      '4': ['FOUR', 'FOR'],\n      '8': ['ATE'],\n      '10': ['TEN', 'TAN', 'TIN', 'TON', 'TUN'],\n    };\n    const possibleWords = soundToWords[spokenWord] || [spokenWord];\n\n    // Check if correct - either direct match OR number sounds like expected word OR matches alias\n    const directMatch = spokenWord === expectedWord || possibleWords.includes(expectedWord);\n    const aliasMatch = store.matchesAlias(expectedWord, rawTranscript, true);\n    const isCorrect = directMatch || aliasMatch;\n\n    // Update display\n    this.currentCharEl.textContent = expectedWord;\n    this.currentCharEl.className = `current-char ${isCorrect ? 'correct' : 'incorrect'}`;\n\n    // Play feedback tone\n    const settings = store.getSettings();\n    if (isCorrect) {\n      playCorrectTone(settings.volume * 0.6);\n    } else {\n      playIncorrectTone(settings.volume * 0.6);\n    }\n\n    if (isCorrect) {\n      this.feedbackTextEl.textContent = `Correct! ${Math.round(responseTime)}ms`;\n      if (this.debugHeardEl) {\n        const wasNumberConversion = possibleWords.includes(expectedWord) && spokenWord !== expectedWord;\n        const aliasNote = aliasMatch && !directMatch ? ' (alias)' : wasNumberConversion ? ' (number)' : '';\n        this.debugHeardEl.textContent = `Heard: \"${rawTranscript}\"${aliasNote} | adjusted: ${Math.round(responseTime)}ms`;\n        this.debugHeardEl.style.color = '#00d26a';\n      }\n    } else {\n      if (settings.repeatUntilCorrect) {\n        // Don't reveal the answer in repeat mode\n        this.feedbackTextEl.textContent = 'Incorrect - try again';\n        this.currentCharEl.textContent = '—';\n        this.currentCharEl.className = 'current-char incorrect';\n      } else {\n        this.feedbackTextEl.textContent = `You said \"${rawTranscript}\" - was \"${expectedWord}\"`;\n      }\n\n      // Always store wrong answer info and show accept button (even in repeat mode)\n      this.lastWrongAnswer = {\n        expected: expectedWord,\n        heard: rawTranscript,\n        responseTime,\n        isWordMode: true,\n      };\n      this.showAcceptButton();\n    }\n\n    // Store previous state for recovery before updating history\n    const wordChars = expectedWord.split('');\n    const previousWMAs: Record<string, { wma: number; mostRecent: number }> = {};\n    for (const char of wordChars) {\n      const charHistory = store.getWordCharacterHistory(char);\n      previousWMAs[char] = { wma: charHistory.wma, mostRecent: charHistory.mostRecent };\n    }\n    this.lastAttempt = {\n      type: 'word',\n      value: expectedWord,\n      chars: wordChars,\n      wasCorrect: isCorrect,\n      previousWMAs\n    };\n\n    // Update word character history for EACH character in the word\n    // Split the response time by number of characters\n    const perCharTime = responseTime / expectedWord.length;\n    for (const char of expectedWord) {\n      const charHistory = store.getWordCharacterHistory(char);\n      const newWMA = calculateWMA(charHistory.wma, perCharTime, isCorrect);\n\n      store.updateWordCharacterHistory(char, {\n        wma: newWMA,\n        mostRecent: isCorrect ? perCharTime : calculatePenaltyTime(charHistory.wma),\n        totalAttempts: charHistory.totalAttempts + 1,\n        correctAttempts: charHistory.correctAttempts + (isCorrect ? 1 : 0),\n        lastPracticed: Date.now(),\n      });\n    }\n\n    // Update session stats\n    store.updateSession({\n      totalCharsThisSession: session.totalCharsThisSession + 1,\n    });\n\n    // Schedule next word (cancel any previous pending)\n    if (this.nextCharTimeout) {\n      clearTimeout(this.nextCharTimeout);\n    }\n\n    if (!isCorrect && settings.repeatUntilCorrect) {\n      // Repeat mode: wait longer to give time for \"Accept My Answer\", then replay\n      this.nextCharTimeout = window.setTimeout(() => {\n        this.nextCharTimeout = null;\n        this.hideAcceptButton();\n        if (store.getSession().isRunning) {\n          this.replayCurrentWord();\n        }\n      }, WRONG_ANSWER_DELAY);\n    } else if (!isCorrect) {\n      // Wrong answer (not in repeat mode): wait longer to give time for \"Accept My Answer\"\n      this.nextCharTimeout = window.setTimeout(() => {\n        this.nextCharTimeout = null;\n        this.hideAcceptButton();\n        if (store.getSession().isRunning) {\n          this.playNextCharacter(); // This will delegate to playNextWord in word mode\n        }\n      }, WRONG_ANSWER_DELAY);\n    } else {\n      // Correct answer: move to next quickly\n      this.nextCharTimeout = window.setTimeout(() => {\n        this.nextCharTimeout = null;\n        if (store.getSession().isRunning) {\n          this.playNextCharacter(); // This will delegate to playNextWord in word mode\n        }\n      }, NEXT_CHAR_DELAY);\n    }\n  }\n\n  private async replayCurrentWord(): Promise<void> {\n    const session = store.getSession();\n    if (!session.isRunning || !this.currentWord) return;\n\n    if (this.isPlayingChar) return;\n    this.isPlayingChar = true;\n\n    const settings = store.getSettings();\n\n    // Reset display\n    this.currentCharEl.textContent = '—';\n    this.currentCharEl.className = 'current-char';\n    this.feedbackTextEl.textContent = 'Listen...';\n    this.listeningIndicator.classList.add('hidden');\n\n    // Set expected to null for word mode\n    if (this.recognizer) {\n      this.recognizer.setExpectedChar(null);\n    }\n\n    // On Android (non-continuous mode), start recognition BEFORE playing morse\n    if (isAndroid() && !this.useContinuousMode && this.recognizer) {\n      console.log('Android: starting recognition before morse word replay (chime will play)');\n      this.recognizer.start();\n      this.feedbackTextEl.textContent = 'Starting...';\n      await new Promise(resolve => setTimeout(resolve, 2000));\n\n      if (!store.getSession().isRunning) {\n        this.isPlayingChar = false;\n        return;\n      }\n      this.feedbackTextEl.textContent = 'Listen...';\n    } else if (this.recognizer) {\n      if (this.useContinuousMode) {\n        this.recognizer.ignoreResults();\n      } else {\n        this.recognizer.stop();\n      }\n    }\n\n    // Play the same word again\n    const completed = await playMorseWord(\n      this.currentWord,\n      settings.characterSpeed,\n      settings.toneFrequency,\n      settings.volume\n    );\n\n    if (!store.getSession().isRunning || !completed) {\n      this.isPlayingChar = false;\n      return;\n    }\n\n    this.audioPlayedAt = performance.now();\n    this.isPlayingChar = false;\n\n    this.feedbackTextEl.textContent = 'Speak the word';\n    this.listeningIndicator.classList.remove('hidden');\n\n    // Handle post-audio recognition setup\n    if (this.recognizer) {\n      if (this.useContinuousMode) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n        this.audioPlayedAt = performance.now();\n        this.recognizer.acceptResults();\n      } else if (!isAndroid()) {\n        this.recognizer.start();\n      }\n      // Android: recognition was already started before morse audio\n    }\n  }\n\n  // ==================== CALLSIGN MODE ====================\n\n  private async playNextCallsign(): Promise<void> {\n    const session = store.getSession();\n    if (!session.isRunning) return;\n\n    const activeChars = store.getActiveCharacters();\n    const settings = store.getSettings();\n    const callsignSettings = store.getCallsignModeSettings();\n    const callsignHistory = store.getCallsignHistory();\n\n    // Check if any formats are enabled\n    if (callsignSettings.enabledFormats.length === 0) {\n      this.feedbackTextEl.textContent = 'No callsign formats selected';\n      this.isPlayingChar = false;\n      this.stop();\n      return;\n    }\n\n    // Generate next callsign\n    const callsign = generateRandomCallsign(\n      callsignSettings.enabledFormats,\n      callsignHistory,\n      activeChars,\n      settings.adaptiveGain,\n      this.previousCallsign\n    );\n\n    this.currentCallsign = callsign;\n    this.previousCallsign = callsign;\n    this.currentWord = null; // Clear word state\n    store.updateSession({ currentChar: callsign });\n\n    // Reset display\n    this.currentCharEl.textContent = '—';\n    this.currentCharEl.className = 'current-char';\n    this.feedbackTextEl.textContent = 'Listen...';\n    this.listeningIndicator.classList.add('hidden');\n\n    // Set expected to null and enable callsign mode\n    if (this.recognizer) {\n      this.recognizer.setExpectedChar(null);\n      if (this.recognizer instanceof SpeechRecognizer) {\n        this.recognizer.setCallsignMode(true, callsign.length);\n      }\n    }\n\n    // On Android (non-continuous mode), start recognition BEFORE playing morse\n    if (isAndroid() && !this.useContinuousMode && this.recognizer) {\n      console.log('Android: starting recognition before morse callsign (chime will play)');\n      this.recognizer.start();\n      this.feedbackTextEl.textContent = 'Starting...';\n      await new Promise(resolve => setTimeout(resolve, 2000));\n\n      if (!store.getSession().isRunning) {\n        this.isPlayingChar = false;\n        return;\n      }\n      this.feedbackTextEl.textContent = 'Listen...';\n    } else if (this.recognizer) {\n      if (this.useContinuousMode) {\n        this.recognizer.ignoreResults();\n      } else {\n        this.recognizer.stop();\n      }\n    }\n\n    // Play morse callsign (reuse playMorseWord since it handles multi-character)\n    const completed = await playMorseWord(\n      callsign,\n      settings.characterSpeed,\n      settings.toneFrequency,\n      settings.volume\n    );\n\n    // Check if session was stopped during playback\n    if (!store.getSession().isRunning || !completed) {\n      this.isPlayingChar = false;\n      return;\n    }\n\n    // Record when audio finished\n    this.audioPlayedAt = performance.now();\n    this.isPlayingChar = false;\n\n    // Start listening\n    this.feedbackTextEl.textContent = 'Speak the callsign (use phonetics)';\n    this.listeningIndicator.classList.remove('hidden');\n\n    // Handle post-audio recognition setup\n    if (this.recognizer) {\n      if (this.useContinuousMode) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n        this.audioPlayedAt = performance.now();\n        this.recognizer.acceptResults();\n      } else if (!isAndroid()) {\n        this.recognizer.start();\n      }\n      // Android: recognition was already started before morse audio\n    }\n  }\n\n  private handleCallsignRecognitionResult(rawTranscript: string, timestamp: number): void {\n    const session = store.getSession();\n    if (!session.isRunning || !this.currentCallsign) return;\n\n    // Stop accepting results and disable callsign mode\n    if (this.recognizer) {\n      if (this.recognizer instanceof SpeechRecognizer) {\n        this.recognizer.setCallsignMode(false);\n      }\n      if (this.useContinuousMode && this.recognizer instanceof SpeechRecognizer) {\n        this.recognizer.ignoreResults();\n      } else {\n        this.recognizer.stop();\n      }\n    }\n    this.listeningIndicator.classList.add('hidden');\n    this.hideAcceptButton();\n\n    // Calculate response time\n    const rawResponseTime = timestamp - this.audioPlayedAt;\n    const responseTime = Math.max(100, rawResponseTime - SPEECH_API_LATENCY);\n\n    // Validate the callsign using flexible word matching\n    const result = validateCallsign(this.currentCallsign, rawTranscript);\n    const isCorrect = result.isCorrect;\n\n    // Update display\n    this.currentCharEl.textContent = this.currentCallsign;\n    this.currentCharEl.className = `current-char ${isCorrect ? 'correct' : 'incorrect'}`;\n\n    // Play feedback tone\n    const settings = store.getSettings();\n    if (isCorrect) {\n      playCorrectTone(settings.volume * 0.6);\n    } else {\n      playIncorrectTone(settings.volume * 0.6);\n    }\n\n    if (isCorrect) {\n      this.feedbackTextEl.textContent = `Correct! ${Math.round(responseTime)}ms`;\n      if (this.debugHeardEl) {\n        this.debugHeardEl.textContent = `Heard: \"${rawTranscript}\" → ${result.parsed} | ${Math.round(responseTime)}ms`;\n        this.debugHeardEl.style.color = '#00d26a';\n      }\n    } else {\n      const errorDesc = getErrorDescription(result);\n      if (settings.repeatUntilCorrect) {\n        this.feedbackTextEl.textContent = `Incorrect - ${errorDesc}`;\n        this.currentCharEl.textContent = '—';\n        this.currentCharEl.className = 'current-char incorrect';\n      } else {\n        this.feedbackTextEl.textContent = `${errorDesc} - was \"${this.currentCallsign}\"`;\n      }\n\n      if (this.debugHeardEl) {\n        this.debugHeardEl.textContent = `Heard: \"${rawTranscript}\" → ${result.parsed || '(nothing)'}`;\n        this.debugHeardEl.style.color = '#ff4757';\n      }\n    }\n\n    // Store previous state for recovery before updating history\n    const callsignChars = this.currentCallsign.split('');\n    const previousWMAs: Record<string, { wma: number; mostRecent: number }> = {};\n    for (const char of callsignChars) {\n      const charHistory = store.getCallsignCharacterHistory(char);\n      previousWMAs[char] = { wma: charHistory.wma, mostRecent: charHistory.mostRecent };\n    }\n    this.lastAttempt = {\n      type: 'callsign',\n      value: this.currentCallsign,\n      chars: callsignChars,\n      wasCorrect: isCorrect,\n      previousWMAs\n    };\n\n    // Update callsign character history for EACH character in the callsign\n    const perCharTime = responseTime / this.currentCallsign.length;\n    for (const char of this.currentCallsign) {\n      const charHistory = store.getCallsignCharacterHistory(char);\n      const newWMA = calculateWMA(charHistory.wma, perCharTime, isCorrect);\n\n      store.updateCallsignCharacterHistory(char, {\n        wma: newWMA,\n        mostRecent: isCorrect ? perCharTime : calculatePenaltyTime(charHistory.wma),\n        totalAttempts: charHistory.totalAttempts + 1,\n        correctAttempts: charHistory.correctAttempts + (isCorrect ? 1 : 0),\n        lastPracticed: Date.now(),\n      });\n    }\n\n    // Update session stats\n    store.updateSession({\n      totalCharsThisSession: session.totalCharsThisSession + 1,\n    });\n\n    // Schedule next callsign\n    if (this.nextCharTimeout) {\n      clearTimeout(this.nextCharTimeout);\n    }\n\n    if (!isCorrect && settings.repeatUntilCorrect) {\n      // Repeat mode: replay the same callsign after longer delay\n      this.nextCharTimeout = window.setTimeout(() => {\n        this.nextCharTimeout = null;\n        if (store.getSession().isRunning) {\n          this.replayCurrentCallsign();\n        }\n      }, CALLSIGN_WRONG_DELAY);\n    } else if (!isCorrect) {\n      // Wrong answer (not in repeat mode): longer delay to review the answer\n      this.nextCharTimeout = window.setTimeout(() => {\n        this.nextCharTimeout = null;\n        if (store.getSession().isRunning) {\n          this.playNextCharacter(); // Will route to callsign mode\n        }\n      }, CALLSIGN_WRONG_DELAY);\n    } else {\n      // Correct answer: move to next quickly\n      this.nextCharTimeout = window.setTimeout(() => {\n        this.nextCharTimeout = null;\n        if (store.getSession().isRunning) {\n          this.playNextCharacter(); // Will route to callsign mode\n        }\n      }, NEXT_CHAR_DELAY);\n    }\n  }\n\n  private async replayCurrentCallsign(): Promise<void> {\n    const session = store.getSession();\n    if (!session.isRunning || !this.currentCallsign) return;\n\n    if (this.isPlayingChar) return;\n    this.isPlayingChar = true;\n\n    const settings = store.getSettings();\n\n    // Reset display\n    this.currentCharEl.textContent = '—';\n    this.currentCharEl.className = 'current-char';\n    this.feedbackTextEl.textContent = 'Listen...';\n    this.listeningIndicator.classList.add('hidden');\n\n    // Set expected to null and enable callsign mode\n    if (this.recognizer) {\n      this.recognizer.setExpectedChar(null);\n      if (this.recognizer instanceof SpeechRecognizer) {\n        this.recognizer.setCallsignMode(true, this.currentCallsign.length);\n      }\n    }\n\n    // On Android (non-continuous mode), start recognition BEFORE playing morse\n    if (isAndroid() && !this.useContinuousMode && this.recognizer) {\n      console.log('Android: starting recognition before morse callsign replay (chime will play)');\n      this.recognizer.start();\n      this.feedbackTextEl.textContent = 'Starting...';\n      await new Promise(resolve => setTimeout(resolve, 2000));\n\n      if (!store.getSession().isRunning) {\n        this.isPlayingChar = false;\n        return;\n      }\n      this.feedbackTextEl.textContent = 'Listen...';\n    } else if (this.recognizer) {\n      if (this.useContinuousMode) {\n        this.recognizer.ignoreResults();\n      } else {\n        this.recognizer.stop();\n      }\n    }\n\n    // Replay the same callsign\n    const completed = await playMorseWord(\n      this.currentCallsign,\n      settings.characterSpeed,\n      settings.toneFrequency,\n      settings.volume\n    );\n\n    if (!store.getSession().isRunning || !completed) {\n      this.isPlayingChar = false;\n      return;\n    }\n\n    this.audioPlayedAt = performance.now();\n    this.isPlayingChar = false;\n\n    this.feedbackTextEl.textContent = 'Speak the callsign (use phonetics)';\n    this.listeningIndicator.classList.remove('hidden');\n\n    // Handle post-audio recognition setup\n    if (this.recognizer) {\n      if (this.useContinuousMode) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n        this.audioPlayedAt = performance.now();\n        this.recognizer.acceptResults();\n      } else if (!isAndroid()) {\n        this.recognizer.start();\n      }\n      // Android: recognition was already started before morse audio\n    }\n  }\n\n  // ==================== END CALLSIGN MODE ====================\n\n  private checkBreakReminder(): void {\n    const session = store.getSession();\n    if (!session.isRunning) return;\n\n    const timeSinceBreak = Date.now() - session.lastBreakReminder;\n    if (timeSinceBreak >= BREAK_REMINDER_INTERVAL) {\n      this.breakModal.classList.remove('hidden');\n    }\n  }\n\n}\n","import { isIOS } from '../core/speech-recognition';\n\nexport async function checkMicrophonePermission(): Promise<'granted' | 'prompt' | 'denied'> {\n  if (navigator.permissions?.query) {\n    try {\n      const result = await navigator.permissions.query({ name: 'microphone' as PermissionName });\n      return result.state;\n    } catch {\n      // Permissions API doesn't support microphone on this browser (e.g., iOS Safari)\n    }\n  }\n  return 'prompt'; // Fallback: trigger getUserMedia to find out\n}\n\nexport async function requestMicrophonePermission(): Promise<boolean> {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n    stream.getTracks().forEach(track => track.stop()); // Release immediately\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function getDeniedInstructions(): string {\n  const isIOSSafari = /Safari/.test(navigator.userAgent) && isIOS();\n  const isChromeMobile = /Chrome/.test(navigator.userAgent) && /Mobile/.test(navigator.userAgent);\n\n  if (isIOSSafari) {\n    return 'Go to Settings → Safari → Microphone and enable access for this site.';\n  } else if (isChromeMobile) {\n    return 'Tap the lock icon in the address bar → Site settings → Microphone → Allow.';\n  }\n  return 'Click the lock/info icon in your browser\\'s address bar and allow microphone access, then refresh.';\n}\n","import './styles/main.css';\nimport { ProgressChart } from './components/progress-chart';\nimport { SettingsPanel } from './components/settings-panel';\nimport { MicTest } from './components/mic-test';\nimport { ModeSelector } from './components/mode-selector';\nimport { PracticeSession } from './services/practice-session';\nimport { isAndroid, isMobile, isSpeechRecognitionSupported } from './core/speech-recognition';\nimport { checkMicrophonePermission, requestMicrophonePermission, getDeniedInstructions } from './services/permission-check';\n\n// Check if Android and show unsupported banner\nfunction checkAndroidAndShowBanner(): boolean {\n  if (isAndroid()) {\n    console.log('Android detected - showing unsupported banner');\n    const androidBanner = document.getElementById('android-banner');\n    const micTestArea = document.getElementById('mic-test-area');\n    const practiceArea = document.getElementById('practice-area');\n    const chartSection = document.getElementById('chart-section');\n\n    // Show the Android banner\n    if (androidBanner) {\n      androidBanner.classList.remove('hidden');\n    }\n\n    // Hide the practice functionality\n    if (micTestArea) {\n      micTestArea.classList.add('hidden');\n    }\n    if (practiceArea) {\n      practiceArea.classList.add('hidden');\n    }\n    if (chartSection) {\n      chartSection.classList.add('hidden');\n    }\n\n    return true; // Android detected, don't proceed with app initialization\n  }\n  return false;\n}\n\n// Initialize the main app components\nfunction initializeApp() {\n  console.log('Morse ICR Trainer initializing...');\n\n  // Check for Android first - if detected, show banner and don't initialize\n  if (checkAndroidAndShowBanner()) {\n    console.log('Android device - app disabled');\n    return;\n  }\n\n  // Log platform detection\n  if (isMobile()) {\n    console.log('Mobile detected - using continuous speech recognition mode');\n    // Hide mic test section on mobile (not needed with continuous mode)\n    const micTestArea = document.getElementById('mic-test-area');\n    if (micTestArea) {\n      micTestArea.style.display = 'none';\n    }\n  }\n\n  if (!isSpeechRecognitionSupported()) {\n    console.warn('Speech recognition not supported in this browser');\n  }\n\n  // Initialize components (they handle their own iOS/browser detection)\n  // Skip MicTest on mobile since it's hidden\n  if (!isMobile()) {\n    new MicTest();\n  }\n\n  // Initialize progress chart\n  const progressChart = new ProgressChart('progress-chart');\n\n  // Initialize mode selector and practice session\n  const modeSelector = new ModeSelector();\n  const practiceSession = new PracticeSession();\n\n  // Wire up chart toggle buttons\n  const charChartBtn = document.getElementById('char-chart-btn') as HTMLButtonElement;\n  const wordChartBtn = document.getElementById('word-chart-btn') as HTMLButtonElement;\n  const callsignChartBtn = document.getElementById('callsign-chart-btn') as HTMLButtonElement;\n\n  const setChartMode = (mode: 'character' | 'word' | 'callsign') => {\n    charChartBtn?.classList.remove('active');\n    wordChartBtn?.classList.remove('active');\n    callsignChartBtn?.classList.remove('active');\n\n    if (mode === 'word') {\n      wordChartBtn?.classList.add('active');\n      progressChart.setDataSource('word');\n    } else if (mode === 'callsign') {\n      callsignChartBtn?.classList.add('active');\n      progressChart.setDataSource('callsign');\n    } else {\n      charChartBtn?.classList.add('active');\n      progressChart.setDataSource('individual');\n    }\n  };\n\n  charChartBtn?.addEventListener('click', () => setChartMode('character'));\n  wordChartBtn?.addEventListener('click', () => setChartMode('word'));\n  callsignChartBtn?.addEventListener('click', () => setChartMode('callsign'));\n\n  // Wire up mode changes to stop session and sync chart\n  modeSelector.setOnModeChange(() => {\n    practiceSession.stop();\n  });\n\n  modeSelector.setOnChartToggle((mode) => {\n    // Sync chart with practice mode\n    setChartMode(mode);\n  });\n\n  new SettingsPanel();\n\n  console.log('Morse ICR Trainer ready!');\n}\n\n// Check microphone permission and show gate if needed\nasync function initWithPermissionCheck() {\n  // Check for Android first - if detected, show banner and don't proceed\n  if (checkAndroidAndShowBanner()) {\n    console.log('Android device - skipping permission check');\n    return;\n  }\n\n  const gate = document.getElementById('permission-gate')!;\n  const btn = document.getElementById('grant-permission-btn') as HTMLButtonElement;\n  const errorEl = document.getElementById('permission-error')!;\n\n  const state = await checkMicrophonePermission();\n\n  if (state === 'granted') {\n    // Already have permission - proceed silently (Option B)\n    initializeApp();\n    return;\n  }\n\n  // Show permission gate\n  gate.classList.remove('hidden');\n\n  if (state === 'denied') {\n    errorEl.innerHTML = `<span class=\"error\">Microphone access was denied.</span><br><small>${getDeniedInstructions()}</small>`;\n    errorEl.classList.remove('hidden');\n  }\n\n  btn.addEventListener('click', async () => {\n    btn.disabled = true;\n    btn.textContent = 'Requesting...';\n\n    const granted = await requestMicrophonePermission();\n    if (granted) {\n      gate.classList.add('hidden');\n      initializeApp();\n    } else {\n      btn.disabled = false;\n      btn.textContent = 'Enable Microphone';\n      errorEl.innerHTML = `<span class=\"error\">Microphone access was denied.</span><br><small>${getDeniedInstructions()}</small>`;\n      errorEl.classList.remove('hidden');\n    }\n  });\n}\n\n// Initialize app when DOM is ready\ndocument.addEventListener('DOMContentLoaded', () => {\n  initWithPermissionCheck();\n});\n\n// Register service worker for PWA (if available)\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', () => {\n    navigator.serviceWorker.register('./sw.js').catch((err) => {\n      console.log('Service worker registration failed:', err);\n    });\n  });\n}\n"],"names":["WMA_DECAY","DEFAULT_WMA","MAX_PENALTY_TIME","calculatePenaltyTime","currentWMA","calculateWMA","previousWMA","responseTime","isCorrect","effectiveTime","getDefaultWMA","getPerformanceLevel","wma","THRESHOLDS","CHARACTER_SETS","SESSION_ORDER","getActiveCharacters","selectedSets","included","excluded","charSet","setName","chars","char","DEFAULT_CHARACTER_SET","DEFAULT_SETTINGS","DEFAULT_SESSION","DEFAULT_CALIBRATION","DEFAULT_WORD_MODE_SETTINGS","DEFAULT_CALLSIGN_MODE_SETTINGS","Store","stored","parsed","e","toSave","key","value","keyListeners","listener","wildcardListeners","updates","current","history","wasCorrect","previousMostRecent","previousWMAs","prev","heardTranscript","transcripts","t","expected","isWordMode","heardText","normalizedHeard","aliases","alias","normalizedAlias","filtered","a","imported","store","MORSE_CODES","code","ALL_CHARACTERS","CHAR_DISPLAY_NAMES","getCharDisplayName","COLORS","CONFIG","ProgressChart","canvasId","source","container","containerRect","dpr","canvasWidth","canvasHeight","rect","x","y","touch","chartWidth","numChars","gapRatio","denominator","barWidth","barGap","totalBarsWidth","startX","dotRadius","mouseX","_mouseY","activeChars","i","charHistory","mostRecent","displayChar","chartHeight","logMin","logMax","ratio","width","height","barY","barHeight","level","cornerRadius","dotY","fontSize","label","icrY","crY","labels","FILE_VERSION","exportHistory","state","exportData","blob","url","link","timestamp","importHistory","file","text","data","resetAllHistory","audioContext","activeOscillators","playbackAborted","getAudioContext","stopAllAudio","osc","resumeAudioContext","ctx","getMorseTiming","wpm","ditDuration","playTone","frequency","duration","startTime","volume","oscillator","gainNode","attackTime","releaseTime","o","playMorseCharacter","timing","currentTime","totalDuration","elementDuration","resolve","playMorseWord","word","charIndex","playTestTone","playCorrectTone","now","playIncorrectTone","NATO_ALPHABET","SPEECH_MAP","isSpeechRecognitionSupported","isIOS","isAndroid","isMobile","buildUserSpeechMap","calibration","userMap","transcript","normalizeRecognizedText","expectedChar","normalized","settings","userCalibration","firstWord","nonLetterEntries","SpeechRecognizer","SpeechRecognitionClass","enabled","event","result","confidence","status","wordCount","w","isShortWord","hasEnoughWords","shouldSend","responseTimestamp","j","normalizedChar","err","wasListening","expectedLength","callback","ALL_CALIBRATION_CHARS","VoiceCalibration","recordBtn","rawTranscript","_normalized","currentChar","btn","progress","SettingsPanel","actionsSection","calibrationSection","charCount","date","config","setNames","name","newSets","s","isActive","newIncluded","newExcluded","c","MicTest","iosMsg","bestTranscript","bestNormalized","tracks","track","dataArray","average","b","THREE_LETTER_WORDS","FOUR_LETTER_WORDS","FIVE_LETTER_WORDS","WORD_LISTS","getWordsByLength","length","filterWordsByActiveChars","words","activeSet","calculateWordWeakness","wordHistory","defaultWMA","sum","selectNextWord","wordLength","adaptiveGain","previousWord","allWords","validWords","weights","weakness","exponent","weight","totalWeight","random","cumulative","isWordModeAvailable","getAvailableWordCount","ModeSelector","checkbox","callsignSettings","mode","count","enabledFormats","enabledCount","examples","exampleList","f","suffix","selectNextCharacter","previousChar","CALLSIGN_FORMATS","US_PREFIX_FIRST","ALL_LETTERS","DIGITS","getFormatsByIds","ids","selectWeightedChar","candidates","callsignHistory","generateCallsign","format","activeLetters","l","activeDigits","d","lettersToUse","digitsToUse","validFirstLetters","firstLetterCandidates","callsign","selectRandomFormat","enabledFormatIds","formats","generateRandomCallsign","previousCallsign","attempts","NUMBER_WORDS","parseWordToChar","ordinalMatch","firstChar","parseWordsToCallsign","validateCallsign","expectedUpper","errors","maxLen","parsedChar","getErrorDescription","BREAK_REMINDER_INTERVAL","NEXT_CHAR_DELAY","WRONG_ANSWER_DELAY","CALLSIGN_WRONG_DELAY","SPEECH_API_LATENCY","AudioLevelMonitor","PracticeSession","session","type","currentTotal","upper","similarGroups","group","heard","similarWords","savedCount","perCharTime","newWMA","recognizer","error","chimeDelay","wordModeSettings","completed","delay","recognized","rawResponseTime","directMatch","aliasMatch","aliasNote","isUnrecognized","recognizedDisplay","spokenWord","expectedWord","possibleWords","wasNumberConversion","wordChars","errorDesc","callsignChars","checkMicrophonePermission","requestMicrophonePermission","getDeniedInstructions","isIOSSafari","isChromeMobile","checkAndroidAndShowBanner","androidBanner","micTestArea","practiceArea","chartSection","initializeApp","progressChart","modeSelector","practiceSession","charChartBtn","wordChartBtn","callsignChartBtn","setChartMode","initWithPermissionCheck","gate","errorEl"],"mappings":"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,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,MAC1C,EAGMC,GAA8B,CAClC,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,SAAU,QAAS,QAAS,QAAS,QAAS,QAChE,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,OAAQ,QAAS,QAAS,QAC9D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAC/D,QAAS,QAAS,QAA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"}